Disassembly Listing for dsPIC33MotionControl
Generated From:
C:/Users/Raffaello/Dropbox/MicrochipProject/dsPIC33MotionControl.X/dist/XC16_dsPIC33FJ128MC802/production/dsPIC33MotionControl.X.production.elf
23-lug-2013 21.35.32

---  C:/Users/Raffaello/Dropbox/MicrochipProject/dsPIC33MotionControl.X/user.c  -------------------------
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                #include <stdint.h>          /* For uint16_t definition                       */
17:                #include <stdbool.h>         /* For true/false definition                     */
18:                #include <dsp.h>             /* For DSP functionality                         */
19:                #include <string.h>
20:                #include <assert.h>
21:                #include "user.h"            /* variables/params used by user.c               */
22:                #include "system.h"
23:                
24:                /******************************************************************************/
25:                /* Global Variable Declaration                                                */
26:                /******************************************************************************/
27:                
28:                /******************************************************************************/
29:                /* User Functions                                                             */
30:                /******************************************************************************/
31:                
32:                /* <Initialize variables in user.h and insert code for user algorithms.> */
33:                
34:                void InitApp(void) {
002036  FA0000     LNK #0x0
35:                    // Unlock Registers  *****************************************
36:                    asm volatile ( "mov #OSCCONL, w1 \n"
002038  207421     MOV #0x742, W1
00203A  200452     MOV #0x45, W2
00203C  200573     MOV #0x57, W3
00203E  784882     MOV.B W2, [W1]
002040  784883     MOV.B W3, [W1]
002042  A9C742     BCLR OSCCON, #6
37:                                "mov #0x45, w2 \n"
38:                                "mov #0x57, w3 \n"
39:                                "mov.b w2, [w1] \n"
40:                                "mov.b w3, [w1] \n"
41:                                "bclr OSCCON, #6 ");
42:                    //**********************************************************//
43:                    // Configure Input Functions
44:                    //Encoder
45:                    RPINR7bits.IC1R = 5; // Assign Input Capture 1 To Pin RP5
002044  803471     MOV RPINR7, W1
002046  2FFE00     MOV #0xFFE0, W0
002048  608000     AND W1, W0, W0
00204A  B30050     IOR #0x5, W0
00204C  883470     MOV W0, RPINR7
46:                    RPINR7bits.IC2R = 10; // Assign Input Capture 2 To Pin RP10
00204E  803471     MOV RPINR7, W1
002050  2E0FF0     MOV #0xE0FF, W0
002052  608080     AND W1, W0, W1
002054  20A000     MOV #0xA00, W0
002056  708000     IOR W1, W0, W0
002058  883470     MOV W0, RPINR7
47:                    RPINR14bits.QEA1R = 5; // Assign QEA1 To Pin RP5
00205A  8034E1     MOV RPINR14, W1
00205C  2FFE00     MOV #0xFFE0, W0
00205E  608000     AND W1, W0, W0
002060  B30050     IOR #0x5, W0
002062  8834E0     MOV W0, RPINR14
48:                    RPINR14bits.QEB1R = 6; // Assign QEB1 To Pin RP6
002064  8034E1     MOV RPINR14, W1
002066  2E0FF0     MOV #0xE0FF, W0
002068  608080     AND W1, W0, W1
00206A  206000     MOV #0x600, W0
00206C  708000     IOR W1, W0, W0
00206E  8834E0     MOV W0, RPINR14
49:                    RPINR16bits.QEA2R = 11; // Assign QEA2 To Pin RP11
002070  803501     MOV RPINR16, W1
002072  2FFE00     MOV #0xFFE0, W0
002074  608000     AND W1, W0, W0
002076  B300B0     IOR #0xB, W0
002078  883500     MOV W0, RPINR16
50:                    RPINR16bits.QEB2R = 10; // Assign QEB2 To Pin RP10
00207A  803501     MOV RPINR16, W1
00207C  2E0FF0     MOV #0xE0FF, W0
00207E  608080     AND W1, W0, W1
002080  20A000     MOV #0xA00, W0
002082  708000     IOR W1, W0, W0
002084  883500     MOV W0, RPINR16
51:                    //UART RX
52:                    RPINR18bits.U1RXR = 8; // Assign U1RX To Pin RP8
002086  803521     MOV RPINR18, W1
002088  2FFE00     MOV #0xFFE0, W0
00208A  608000     AND W1, W0, W0
00208C  A03000     BSET W0, #3
00208E  883520     MOV W0, RPINR18
53:                
54:                    // Configure Output Functions
55:                    //UART TX
56:                    RPOR4bits.RP9R = 3; // Assign U1Tx To Pin RP9
002090  803641     MOV RPOR4, W1
002092  2E0FF0     MOV #0xE0FF, W0
002094  608080     AND W1, W0, W1
002096  203000     MOV #0x300, W0
002098  708000     IOR W1, W0, W0
00209A  883640     MOV W0, RPOR4
57:                
58:                    //************************************************************
59:                    // Lock Registers ********************************************
60:                    asm volatile ( "mov #OSCCONL, w1 \n"
00209C  207421     MOV #0x742, W1
00209E  200452     MOV #0x45, W2
0020A0  200573     MOV #0x57, W3
0020A2  784882     MOV.B W2, [W1]
0020A4  784883     MOV.B W3, [W1]
0020A6  A8C742     BSET OSCCON, #6
61:                                "mov #0x45, w2 \n"
62:                                "mov #0x57, w3 \n"
63:                                "mov.b w2, [w1] \n"
64:                                "mov.b w3, [w1] \n"
65:                                "bset OSCCON, #6");
66:                    //**********************************************************//
67:                
68:                    /* Setup analog functionality and port direction */
69:                    _TRISA4 = 0; //Led
0020A8  A982C0     BCLR TRISA, #4
70:                    _TRISB2 = 0; //Enable - Motor 1
0020AA  A942C8     BCLR TRISB, #2
71:                    _TRISB3 = 0; //Enable - Motor 2
0020AC  A962C8     BCLR TRISB, #3
72:                    _TRISB5 = 1;
0020AE  A8A2C8     BSET TRISB, #5
73:                    _TRISB6 = 1;
0020B0  A8C2C8     BSET TRISB, #6
74:                    _TRISB10 = 1;
0020B2  A842C9     BSET 0x2C9, #2
75:                    _TRISB11 = 1;
0020B4  A862C9     BSET 0x2C9, #3
76:                    // TODO Add analog funcionality for ADC
77:                
78:                    /* Initialize peripherals */
79:                    LED = 0;
0020B6  A982C4     BCLR LATA, #4
80:                    InitPWM(); //Open PWM
0020B8  07FCA5     RCALL InitPWM
81:                    InitQEI1(); //Open QEI1
0020BA  07FCC7     RCALL InitQEI1
82:                    InitQEI2(); //Open QEI2
0020BC  07FCDC     RCALL InitQEI2
83:                    InitIC1(); //Open Input Capture 1
0020BE  07FCF1     RCALL InitIC1
84:                    InitIC2(); //Open Input Capture 2
0020C0  07FD09     RCALL InitIC2
85:                    InitTimer2(); //Open Timer2 for InputCapture 1 & 2
0020C2  07FD3A     RCALL InitTimer2
86:                    InitADC(); //Open ADC for measure current motors
0020C4  07FDC6     RCALL InitADC
87:                    InitDMA0(); //Open DMA0 for buffering measures ADC
0020C6  07FD87     RCALL InitDMA0
88:                
89:                    InitUART1(); //Open UART1 for serial comunication
0020C8  07FD68     RCALL InitUART1
90:                    InitDMA1(); //Open DMA1 for Tx UART1
0020CA  07FDA2     RCALL InitDMA1
91:                
92:                    InitTimer1(); //Open Timer1 for clock system
0020CC  07FD1C     RCALL InitTimer1
93:                    InitInterrupts(); //Start others interrupts
0020CE  07FD4A     RCALL InitInterrupts
94:                }
0020D0  FA8000     ULNK
0020D2  060000     RETURN
95:                
96:                /* Protected Memcpy */
97:                void inline protectedMemcpy(unsigned reg, void *destination, const void *source, size_t num) {
0020D4  FA0008     LNK #0x8
0020D6  780F00     MOV W0, [W14]
0020D8  980711     MOV W1, [W14+2]
0020DA  980722     MOV W2, [W14+4]
0020DC  980733     MOV W3, [W14+6]
98:                    if (1 == reg) {
0020DE  78001E     MOV [W14], W0
0020E0  500FE1     SUB W0, #0x1, [W15]
0020E2  3A0009     BRA NZ, 0x20F6
99:                        reg = 0;
0020E4  EB0000     CLR W0
0020E6  780F00     MOV W0, [W14]
100:                       memcpy(destination, source, num);
0020E8  90013E     MOV [W14+6], W2
0020EA  9000AE     MOV [W14+4], W1
0020EC  90001E     MOV [W14+2], W0
0020EE  07F51B     RCALL _memcpy
101:                       reg = 1;
0020F0  200010     MOV #0x1, W0
0020F2  780F00     MOV W0, [W14]
0020F4  370004     BRA 0x20FE
102:                   } else {
103:                       memcpy(destination, source, num);
0020F6  90013E     MOV [W14+6], W2
0020F8  9000AE     MOV [W14+4], W1
0020FA  90001E     MOV [W14+2], W0
0020FC  07F514     RCALL _memcpy
104:                   }
105:               }
0020FE  FA8000     ULNK
002100  060000     RETURN
106:               
107:               int maxValue(float myArray[], size_t size) {
002102  FA000A     LNK #0xA
002104  781F88     MOV W8, [W15++]
002106  980730     MOV W0, [W14+6]
002108  980741     MOV W1, [W14+8]
108:                   /* enforce the contract */
109:               //    assert(myArray && size);
110:                   size_t i;
111:                   float maxValue = myArray[0];
00210A  90003E     MOV [W14+6], W0
00210C  BE0110     MOV.D [W0], W2
00210E  980712     MOV W2, [W14+2]
002110  980723     MOV W3, [W14+4]
112:               
113:                   for (i = 1; i < size; ++i) {
002112  200010     MOV #0x1, W0
002114  780F00     MOV W0, [W14]
002116  370016     BRA 0x2144
002142  E80F1E     INC [W14], [W14]
002144  90004E     MOV [W14+8], W0
002146  78009E     MOV [W14], W1
002148  508F80     SUB W1, W0, [W15]
00214A  39FFE6     BRA NC, 0x2118
114:                       if (myArray[i] > maxValue) {
002118  78001E     MOV [W14], W0
00211A  DD0042     SL W0, #2, W0
00211C  9000BE     MOV [W14+6], W1
00211E  408000     ADD W1, W0, W0
002120  BE0010     MOV.D [W0], W0
002122  B3C018     MOV #0x1, W8
002124  90011E     MOV [W14+2], W2
002126  9001AE     MOV [W14+4], W3
002128  07F329     RCALL ___gtsf2
00212A  500FE0     SUB W0, #0x0, [W15]
00212C  3C0001     BRA GT, 0x2130
00212E  EB4400     CLR.B W8
002130  544FE0     SUB.B W8, #0x0, [W15]
002132  320007     BRA Z, 0x2142
115:                           maxValue = myArray[i];
002134  78001E     MOV [W14], W0
002136  DD0042     SL W0, #2, W0
002138  9000BE     MOV [W14+6], W1
00213A  408000     ADD W1, W0, W0
00213C  BE0110     MOV.D [W0], W2
00213E  980712     MOV W2, [W14+2]
002140  980723     MOV W3, [W14+4]
116:                       }
117:                   }
118:                   return maxValue;
00214C  90001E     MOV [W14+2], W0
00214E  9000AE     MOV [W14+4], W1
002150  07F317     RCALL ___fixsfsi
002152  780000     MOV W0, W0
119:               }
002154  78044F     MOV [--W15], W8
002156  FA8000     ULNK
002158  060000     RETURN
---  C:/Users/Raffaello/Dropbox/MicrochipProject/dsPIC33MotionControl.X/traps.c  ------------------------
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                     #include <xc.h>
8:                 #elif defined(__C30__)
9:                     #if defined(__dsPIC33E__)
10:                    	#include <p33Exxxx.h>
11:                    #elif defined(__dsPIC33F__)
12:                    	#include <p33Fxxxx.h>
13:                    #endif
14:                #endif
15:                
16:                #include <stdint.h>        /* Includes uint16_t definition */
17:                #include <stdbool.h>       /* Includes true/false definition */
18:                
19:                /******************************************************************************/
20:                /* Trap Function Prototypes                                                   */
21:                /******************************************************************************/
22:                
23:                /* <Other function prototypes for debugging trap code may be inserted here>   */
24:                
25:                /* Use if INTCON2 ALTIVT=1 */
26:                void __attribute__((interrupt,no_auto_psv)) _OscillatorFail(void);
27:                void __attribute__((interrupt,no_auto_psv)) _AddressError(void);
28:                void __attribute__((interrupt,no_auto_psv)) _StackError(void);
29:                void __attribute__((interrupt,no_auto_psv)) _MathError(void);
30:                
31:                #if defined(__HAS_DMA__)
32:                
33:                void __attribute__((interrupt,no_auto_psv)) _DMACError(void);
34:                
35:                #endif
36:                
37:                #if defined(__dsPIC33F__)
38:                
39:                /* Use if INTCON2 ALTIVT=0 */
40:                void __attribute__((interrupt,no_auto_psv)) _AltOscillatorFail(void);
41:                void __attribute__((interrupt,no_auto_psv)) _AltAddressError(void);
42:                void __attribute__((interrupt,no_auto_psv)) _AltStackError(void);
43:                void __attribute__((interrupt,no_auto_psv)) _AltMathError(void);
44:                
45:                    #if defined(__HAS_DMA__)
46:                
47:                    void __attribute__((interrupt,no_auto_psv)) _AltDMACError(void);
48:                
49:                    #endif
50:                
51:                #endif
52:                
53:                /* Default interrupt handler */
54:                void __attribute__((interrupt,no_auto_psv)) _DefaultInterrupt(void);
55:                
56:                #if defined(__dsPIC33E__)
57:                
58:                /* These are additional traps in the 33E family.  Refer to the PIC33E
59:                migration guide.  There are no Alternate Vectors in the 33E family. */
60:                void __attribute__((interrupt,no_auto_psv)) _HardTrapError(void);
61:                void __attribute__((interrupt,no_auto_psv)) _SoftTrapError(void);
62:                
63:                #endif
64:                
65:                /******************************************************************************/
66:                /* Trap Handling                                                              */
67:                /*                                                                            */
68:                /* These trap routines simply ensure that the device continuously loops       */
69:                /* within each routine.  Users who actually experience one of these traps     */
70:                /* can add code to handle the error.  Some basic examples for trap code,      */
71:                /* including assembly routines that process trap sources, are available at    */
72:                /* www.microchip.com/codeexamples                                             */
73:                /******************************************************************************/
74:                
75:                /* Primary (non-alternate) address error trap function declarations */
76:                void __attribute__((interrupt,no_auto_psv)) _OscillatorFail(void)
77:                {
0004FC  FA0000     LNK #0x0
78:                        INTCON1bits.OSCFAIL = 0;        /* Clear the trap flag */
0004FE  A92080     BCLR INTCON1, #1
79:                        while(1);
000500  37FFFF     BRA 0x500
80:                }
81:                
82:                void __attribute__((interrupt,no_auto_psv)) _AddressError(void)
83:                {
000502  FA0000     LNK #0x0
84:                        INTCON1bits.ADDRERR = 0;        /* Clear the trap flag */
000504  A96080     BCLR INTCON1, #3
85:                        while (1);
000506  37FFFF     BRA 0x506
86:                }
87:                void __attribute__((interrupt,no_auto_psv)) _StackError(void)
88:                {
000508  FA0000     LNK #0x0
89:                        INTCON1bits.STKERR = 0;         /* Clear the trap flag */
00050A  A94080     BCLR INTCON1, #2
90:                        while (1);
00050C  37FFFF     BRA 0x50C
91:                }
92:                
93:                void __attribute__((interrupt,no_auto_psv)) _MathError(void)
94:                {
00050E  FA0000     LNK #0x0
95:                        INTCON1bits.MATHERR = 0;        /* Clear the trap flag */
000510  A98080     BCLR INTCON1, #4
96:                        while (1);
000512  37FFFF     BRA 0x512
97:                }
98:                
99:                #if defined(__HAS_DMA__)
100:               
101:               void __attribute__((interrupt,no_auto_psv)) _DMACError(void)
102:               {
000514  FA0000     LNK #0x0
103:                       INTCON1bits.DMACERR = 0;        /* Clear the trap flag */
000516  A9A080     BCLR INTCON1, #5
104:                       while (1);
000518  37FFFF     BRA 0x518
105:               }
106:               
107:               #endif
108:               
109:               #if defined(__dsPIC33F__)
110:               
111:               /* Alternate address error trap function declarations */
112:               void __attribute__((interrupt,no_auto_psv)) _AltOscillatorFail(void)
113:               {
00051A  FA0000     LNK #0x0
114:                       INTCON1bits.OSCFAIL = 0;        /* Clear the trap flag */
00051C  A92080     BCLR INTCON1, #1
115:                       while (1);
00051E  37FFFF     BRA 0x51E
116:               }
117:               
118:               void __attribute__((interrupt,no_auto_psv)) _AltAddressError(void)
119:               {
000520  FA0000     LNK #0x0
120:                       INTCON1bits.ADDRERR = 0;        /* Clear the trap flag */
000522  A96080     BCLR INTCON1, #3
121:                       while (1);
000524  37FFFF     BRA 0x524
122:               }
123:               
124:               void __attribute__((interrupt,no_auto_psv)) _AltStackError(void)
125:               {
000526  FA0000     LNK #0x0
126:                       INTCON1bits.STKERR = 0;         /* Clear the trap flag */
000528  A94080     BCLR INTCON1, #2
127:                       while (1);
00052A  37FFFF     BRA 0x52A
128:               }
129:               
130:               void __attribute__((interrupt,no_auto_psv)) _AltMathError(void)
131:               {
00052C  FA0000     LNK #0x0
132:                       INTCON1bits.MATHERR = 0;        /* Clear the trap flag */
00052E  A98080     BCLR INTCON1, #4
133:                       while (1);
000530  37FFFF     BRA 0x530
134:               }
135:               
136:                   #if defined(__HAS_DMA__)
137:               
138:                   void __attribute__((interrupt,no_auto_psv)) _AltDMACError(void)
139:                   {
000532  FA0000     LNK #0x0
140:                        INTCON1bits.DMACERR = 0;        /* Clear the trap flag */
000534  A9A080     BCLR INTCON1, #5
141:                        while (1);
000536  37FFFF     BRA 0x536
142:                   }
143:               
144:                   #endif
145:               
146:               #endif
147:               
148:               /******************************************************************************/
149:               /* Default Interrupt Handler                                                  */
150:               /*                                                                            */
151:               /* This executes when an interrupt occurs for an interrupt source with an     */
152:               /* improperly defined or undefined interrupt handling routine.                */
153:               /******************************************************************************/
154:               void __attribute__((interrupt,no_auto_psv)) _DefaultInterrupt(void)
155:               {
000538  FA0000     LNK #0x0
156:                       while(1);
00053A  37FFFF     BRA 0x53A
157:               }
158:               
159:               #if defined(__dsPIC33E__)
160:               
161:               /* These traps are new to the dsPIC33E family.  Refer to the device Interrupt
162:               chapter of the FRM to understand trap priority. */
163:               void __attribute__((interrupt,no_auto_psv)) _HardTrapError(void)
164:               {
165:                   while(1);
166:               }
167:               void __attribute__((interrupt,no_auto_psv)) _SoftTrapError(void)
168:               {
169:                   while(1);
170:               }
171:               
172:               #endif
---  C:/Users/Raffaello/Dropbox/MicrochipProject/dsPIC33MotionControl.X/system.c  -----------------------
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                #include <stdint.h>          /* For uint16_t definition                       */
17:                #include <stdbool.h>         /* For true/false definition                     */
18:                #include <pwm12.h>
19:                #include <string.h>
20:                
21:                #include "system.h"          /* variables/params used by system.c             */
22:                #include "packet.h"
23:                
24:                #include "serial.h"
25:                
26:                /******************************************************************************/
27:                /* Global Variable Declaration                                                */
28:                /******************************************************************************/
29:                
30:                unsigned int reset_count = 0;
31:                unsigned char version_date_[] = __DATE__;
32:                unsigned char version_time_[] = __TIME__;
33:                
34:                extern unsigned char BufferTx[MAX_TX_BUFF] __attribute__((space(dma)));
35:                
36:                // ADC buffer, 2 channels (AN0, AN1), 32 bytes each, 2 x 32 = 64 bytes
37:                extern int AdcBuffer[ADC_CHANNELS][ADC_BUFF] __attribute__((space(dma), aligned(256)));
38:                
39:                // From motors PID
40:                extern parameter_t parameter;
41:                
42:                /******************************************************************************/
43:                /* System Level Functions                                                     */
44:                /*                                                                            */
45:                /* Custom oscillator configuration funtions, reset source evaluation          */
46:                /* functions, and other non-peripheral microcontroller initialization         */
47:                /* functions get placed in system.c.                                          */
48:                /*                                                                            */
49:                /******************************************************************************/
50:                
51:                /* Refer to the device Family Reference Manual Oscillator section for
52:                information about available oscillator configurations.  Typically
53:                this would involve configuring the oscillator tuning register or clock
54:                switching useing the compiler's __builtin_write_OSCCON functions.
55:                Refer to the C Compiler for PIC24 MCUs and dsPIC DSCs User Guide in the
56:                compiler installation directory /doc folder for documentation on the
57:                __builtin functions.*/
58:                
59:                void init_process(void) {
001922  FA0000     LNK #0x0
60:                    parameter.step_timer = (int) (TMR1_VALUE);
001924  27FFF0     MOV #0x7FFF, W0
001926  8848D0     MOV W0, 0x91A
61:                    parameter.int_tm_mill = (int) (TCTMR1 * 1000);
001928  200010     MOV #0x1, W0
00192A  8848E0     MOV W0, 0x91C
62:                }
00192C  FA8000     ULNK
00192E  060000     RETURN
63:                
64:                unsigned char update_priority(void) {
001930  FA0000     LNK #0x0
65:                    return NACK;
001932  B3C4E0     MOV #0x4E, W0
66:                }
001934  FA8000     ULNK
001936  060000     RETURN
67:                
68:                unsigned char update_frequency(void) {
001938  FA0000     LNK #0x0
69:                    return NACK;
00193A  B3C4E0     MOV #0x4E, W0
70:                }
00193C  FA8000     ULNK
00193E  060000     RETURN
71:                
72:                services_t services(services_t service) {
001940  FA000E     LNK #0xE
001942  781F88     MOV W8, [W15++]
001944  780400     MOV W0, W8
001946  980711     MOV W1, [W14+2]
001948  980722     MOV W2, [W14+4]
00194A  980733     MOV W3, [W14+6]
00194C  980744     MOV W4, [W14+8]
00194E  980755     MOV W5, [W14+10]
001950  980766     MOV W6, [W14+12]
73:                    switch (service.command) {
001952  90402E     MOV.B [W14+2], W0
001954  FB0000     SE W0, W0
001956  2002A1     MOV #0x2A, W1
001958  500F81     SUB W0, W1, [W15]
00195A  320004     BRA Z, 0x1964
00195C  200761     MOV #0x76, W1
00195E  500F81     SUB W0, W1, [W15]
001960  320019     BRA Z, 0x1994
74:                        case RESET:
75:                            if (reset_count < 3) {
001964  804C60     MOV 0x98C, W0
001966  500FE2     SUB W0, #0x2, [W15]
001968  3E0009     BRA GTU, 0x197C
76:                                reset_count++;
00196A  804C60     MOV 0x98C, W0
00196C  E80000     INC W0, W0
00196E  884C60     MOV W0, 0x98C
77:                                //ResetPort = Port;
78:                                service.buffer[0] = ACK;
001970  B3C4B0     MOV #0x4B, W0
001972  984730     MOV.B W0, [W14+3]
79:                                service.buffer[1] = reset_count;
001974  804C60     MOV 0x98C, W0
001976  784000     MOV.B W0, W0
001978  984740     MOV.B W0, [W14+4]
80:                            } else {
81:                                SET_CPU_IPL(7); // disable all user interrupts
00197C  800290     MOV DISICNT, W0
00197E  780F00     MOV W0, [W14]
001980  FC3FFF     DISI #0x3FFF
001982  800211     MOV SR, W1
001984  200E00     MOV #0xE0, W0
001986  708000     IOR W1, W0, W0
001988  880210     MOV W0, SR
00198A  78001E     MOV [W14], W0
00198C  880290     MOV W0, DISICNT
00198E  880000     MOV W0, WREG0
82:                                //DelayN1ms(200);
83:                                asm("RESET");
001990  FE0000     RESET
84:                            }
85:                            break;
00197A  370012     BRA 0x19A0
001992  370006     BRA 0x19A0
86:                        case VERSION_CODE:
87:                            memcpy(service.buffer,version_time_,sizeof(version_time_));
001994  E8800E     INC2 W14, W0
001996  E80000     INC W0, W0
001998  200092     MOV #0x9, W2
00199A  2099A1     MOV #0x99A, W1
00199C  07F8C4     RCALL _memcpy
88:                            break;
00199E  000000     NOP
89:                        default:
90:                            break;
001962  37001E     BRA 0x19A0
91:                    }
92:                    return service;
0019A0  78000E     MOV W14, W0
0019A2  B00020     ADD #0x2, W0
0019A4  09000A     REPEAT #0xA
0019A6  785C30     MOV.B [W0++], [W8++]
0019A8  B100B8     SUB #0xB, W8
93:                }
0019AA  780008     MOV W8, W0
0019AC  78044F     MOV [--W15], W8
0019AE  FA8000     ULNK
0019B0  060000     RETURN
94:                
95:                void ConfigureOscillator(void) {
0019B2  FA0000     LNK #0x0
96:                    PLLFBD = 30; // M=32  //Old configuration: PLLFBD=29 - M=31
0019B4  2001E0     MOV #0x1E, W0
0019B6  883A30     MOV W0, PLLFBD
97:                    CLKDIVbits.PLLPOST = 0; // N1=2
0019B8  803A21     MOV CLKDIV, W1
0019BA  2FF3F0     MOV #0xFF3F, W0
0019BC  608000     AND W1, W0, W0
0019BE  883A20     MOV W0, CLKDIV
98:                    CLKDIVbits.PLLPRE = 0; // N2=2
0019C0  803A21     MOV CLKDIV, W1
0019C2  2FFE00     MOV #0xFFE0, W0
0019C4  608000     AND W1, W0, W0
0019C6  883A20     MOV W0, CLKDIV
99:                    // Disable Watch Dog Timer
100:                   RCONbits.SWDTEN = 0;
0019C8  A9A740     BCLR RCON, #5
101:                   // Clock switching to incorporate PLL
102:                   // Initiate Clock Switch to Primary
103:                   __builtin_write_OSCCONH(0x03); // Oscillator with PLL (NOSC=0b011)
0019CA  200032     MOV #0x3, W2
0019CC  200780     MOV #0x78, W0
0019CE  2009A1     MOV #0x9A, W1
0019D0  207433     MOV #0x743, W3
0019D2  784980     MOV.B W0, [W3]
0019D4  784981     MOV.B W1, [W3]
0019D6  784982     MOV.B W2, [W3]
104:                   __builtin_write_OSCCONL(0x01); // Start clock switching
0019D8  200012     MOV #0x1, W2
0019DA  200460     MOV #0x46, W0
0019DC  200571     MOV #0x57, W1
0019DE  207423     MOV #0x742, W3
0019E0  784980     MOV.B W0, [W3]
0019E2  784981     MOV.B W1, [W3]
0019E4  784982     MOV.B W2, [W3]
105:                   while (OSCCONbits.COSC != 0b011); // Wait for Clock switch to occur
0019E6  000000     NOP
0019E8  803A11     MOV OSCCON, W1
0019EA  270000     MOV #0x7000, W0
0019EC  608080     AND W1, W0, W1
0019EE  230000     MOV #0x3000, W0
0019F0  508F80     SUB W1, W0, [W15]
0019F2  3AFFFA     BRA NZ, 0x19E8
106:                   while (OSCCONbits.LOCK != 1) {
0019F4  000000     NOP
0019F6  803A11     MOV OSCCON, W1
0019F8  200200     MOV #0x20, W0
0019FA  608000     AND W1, W0, W0
0019FC  500FE0     SUB W0, #0x0, [W15]
0019FE  32FFFB     BRA Z, 0x19F6
107:                   }; // Wait for PLL to lock
108:               }
001A00  FA8000     ULNK
001A02  060000     RETURN
109:               
110:               void InitPWM(void) {
001A04  FA000A     LNK #0xA
111:                   // Holds the value to be loaded into dutycycle register
112:                   unsigned int period;
113:                   // Holds the value to be loaded into special event compare register
114:                   unsigned int sptime;
115:                   // Holds PWM configuration value
116:                   unsigned int config1;
117:                   // Holds the value be loaded into PWMCON1 register
118:                   unsigned int config2;
119:                   // Holds the value to config the special event trigger postscale and dutycycle
120:                   unsigned int config3;
121:                   // Config PWM
122:                   period = 2048; // PWM F=19,340Hz counting UP 12bit resolution @ Fcy=39.628 MHz
001A06  208000     MOV #0x800, W0
001A08  780F00     MOV W0, [W14]
123:                   sptime = 0x0;
001A0A  EB0000     CLR W0
001A0C  980710     MOV W0, [W14+2]
124:                   // 1:1 postscaler, 1:1 prescale, free running mode
125:                   // PWM time base ON, count up
126:                   config1 = PWM1_EN & PWM1_IDLE_CON & PWM1_OP_SCALE1 & PWM1_IPCLK_SCALE1 &
001A0E  280000     MOV #0x8000, W0
001A10  980720     MOV W0, [W14+4]
127:                           PWM1_MOD_FREE;
128:                   // PWM1H e PWM1L enabled in complementar mode
129:                   // dsPICs with 3 pairs of PWM pins have one timer only (A)
130:                   config2 = PWM1_MOD1_COMP & PWM1_PEN1L & PWM1_PEN1H &
001A12  20CBB0     MOV #0xCBB, W0
001A14  980730     MOV W0, [W14+6]
131:                           PWM1_MOD2_COMP & PWM1_PEN2L & PWM1_PEN2H &
132:                           PWM1_PDIS3H & PWM1_PDIS3L;
133:                   config3 = PWM1_SEVOPS1 & PWM1_OSYNC_PWM & PWM1_UEN;
001A16  200020     MOV #0x2, W0
001A18  980740     MOV W0, [W14+8]
134:                   OpenMCPWM1(period, sptime, config1, config2, config3);
001A1A  90024E     MOV [W14+8], W4
001A1C  9001BE     MOV [W14+6], W3
001A1E  90012E     MOV [W14+4], W2
001A20  90009E     MOV [W14+2], W1
001A22  78001E     MOV [W14], W0
001A24  07F5E6     RCALL _OpenMCPWM1
135:                   // Dead Time Unit A assigned to both 1 & 2 PWM pairs
136:                   /* SetMCPWM1DeadTimeAssignment(PWM1_DTS1A_UA & PWM1_DTS1I_UA & PWM1_DTS2A_UA & PWM1_DTS2I_UA); */
137:                   P1DTCON2bits.DTS1A = 0;
001A26  A921CE     BCLR DTCON2, #1
138:                   P1DTCON2bits.DTS1I = 0;
001A28  A901CE     BCLR DTCON2, #0
139:                   P1DTCON2bits.DTS2A = 0;
001A2A  A961CE     BCLR DTCON2, #3
140:                   P1DTCON2bits.DTS2I = 0;
001A2C  A941CE     BCLR DTCON2, #2
141:                   // Dead time 100ns = 0.2% of PWM period
142:                   SetMCPWM1DeadTimeGeneration(PWM1_DTA4 & PWM1_DTAPS1);
001A2E  2FF040     MOV #0xFF04, W0
001A30  07F5F0     RCALL _SetMCPWM1DeadTimeGeneration
143:                   // dutycyclereg=1, dutycycle=50% (motore fermo in LAP mode , updatedisable=0
144:                   SetDCMCPWM1(1, 2048, 0);
001A32  EB4100     CLR.B W2
001A34  208001     MOV #0x800, W1
001A36  200010     MOV #0x1, W0
001A38  07F5E2     RCALL _SetDCMCPWM1
145:                   SetDCMCPWM1(2, 2048, 0);
001A3A  EB4100     CLR.B W2
001A3C  208001     MOV #0x800, W1
001A3E  200020     MOV #0x2, W0
001A40  07F5DE     RCALL _SetDCMCPWM1
146:               
147:                   ConfigIntMCPWM1(PWM1_INT_DIS);
001A42  2FFF70     MOV #0xFFF7, W0
001A44  07F5B4     RCALL _ConfigIntMCPWM1
148:               }
001A46  FA8000     ULNK
001A48  060000     RETURN
149:               
150:               void InitQEI1(void) {
001A4A  FA0000     LNK #0x0
151:                   //QEI1CONbits.CNTERR= 0; // No position count error has occurred
152:                   QEI1CONbits.QEISIDL = 1; // Discontinue module operation when device enters Idle mode
001A4C  A8A1E1     BSET 0x1E1, #5
153:                   QEI1CONbits.QEIM = 7; // Quadrature Encoder Interface enabled (x4 mode) with position counter reset by match (MAXxCNT)
001A4E  800F01     MOV QEI1CON, W1
001A50  207000     MOV #0x700, W0
001A52  708000     IOR W1, W0, W0
001A54  880F00     MOV W0, QEI1CON
154:                   QEI1CONbits.SWPAB = 1; // Phase A and Phase B inputs swapped
001A56  A8E1E0     BSET QEI1CON, #7
155:                   QEI1CONbits.PCDOUT = 0; // Position counter direction status output disabled (Normal I/O pin operation)
001A58  A9C1E0     BCLR QEI1CON, #6
156:                   //QEI1CONbits.TQGATE= 0  // Timer gated time accumulation disabled
157:                   //QEI1CONbits.TQCKPS = 0b00	// 1:1 prescale value
158:                   QEI1CONbits.POSRES = 0; // Index pulse does not reset position counter
001A5A  A941E0     BCLR QEI1CON, #2
159:               
160:                   DFLT1CONbits.QEOUT = 1; // Digital filter outputs enabled on QEAx/QEBx/INDXx pins
001A5C  A8E1E2     BSET DFLT1CON, #7
161:                   DFLT1CONbits.QECK = 6; // 1:128 Clock divide for QEAx/QEBx/INDXx
001A5E  800F11     MOV DFLT1CON, W1
001A60  2FF8F0     MOV #0xFF8F, W0
001A62  608080     AND W1, W0, W1
001A64  200600     MOV #0x60, W0
001A66  708000     IOR W1, W0, W0
001A68  880F10     MOV W0, DFLT1CON
162:               
163:                   MAX1CNT = 0xFFFF;
001A6A  EB8000     SETM W0
001A6C  880F30     MOV W0, MAX1CNT
164:                   POS1CNT = 0;
001A6E  EB0000     CLR W0
001A70  880F20     MOV W0, POS1CNT
165:               }
001A72  FA8000     ULNK
001A74  060000     RETURN
166:               
167:               void InitQEI2(void) {
001A76  FA0000     LNK #0x0
168:                   //QEI2CONbits.CNTERR= 0; // No position count error has occurred
169:                   QEI2CONbits.QEISIDL = 1; // Discontinue module operation when device enters Idle mode
001A78  A8A1F1     BSET 0x1F1, #5
170:                   QEI2CONbits.QEIM = 7; // Quadrature Encoder Interface enabled (x4 mode) with position counter reset by match (MAXxCNT)
001A7A  800F81     MOV QEI2CON, W1
001A7C  207000     MOV #0x700, W0
001A7E  708000     IOR W1, W0, W0
001A80  880F80     MOV W0, QEI2CON
171:                   QEI2CONbits.SWPAB = 1; // Phase A and Phase B inputs swapped
001A82  A8E1F0     BSET QEI2CON, #7
172:                   QEI2CONbits.PCDOUT = 0; // Position counter direction status output disabled (Normal I/O pin operation)
001A84  A9C1F0     BCLR QEI2CON, #6
173:                   //QEI2CONbits.TQGATE= 0  // Timer gated time accumulation disabled
174:                   //QEI2CONbits.TQCKPS = 0b00	// 1:1 prescale value
175:                   QEI2CONbits.POSRES = 0; // Index pulse does not reset position counter
001A86  A941F0     BCLR QEI2CON, #2
176:               
177:                   DFLT2CONbits.QEOUT = 1; // Digital filter outputs enabled on QEAx/QEBx/INDXx pins
001A88  A8E1F2     BSET DFLT2CON, #7
178:                   DFLT2CONbits.QECK = 6; // 1:128 Clock divide for QEAx/QEBx/INDXx
001A8A  800F91     MOV DFLT2CON, W1
001A8C  2FF8F0     MOV #0xFF8F, W0
001A8E  608080     AND W1, W0, W1
001A90  200600     MOV #0x60, W0
001A92  708000     IOR W1, W0, W0
001A94  880F90     MOV W0, DFLT2CON
179:               
180:                   MAX2CNT = 0xFFFF;
001A96  EB8000     SETM W0
001A98  880FB0     MOV W0, MAX2CNT
181:                   POS2CNT = 0;
001A9A  EB0000     CLR W0
001A9C  880FA0     MOV W0, POS2CNT
182:               }
001A9E  FA8000     ULNK
001AA0  060000     RETURN
183:               
184:               void InitIC1(void) {
001AA2  FA0000     LNK #0x0
185:                   // Initialize Capture Module
186:                   IC1CONbits.ICM = 0b00; // Disable Input Capture 1 module
001AA4  800A11     MOV IC1CON, W1
001AA6  2FFF80     MOV #0xFFF8, W0
001AA8  608000     AND W1, W0, W0
001AAA  880A10     MOV W0, IC1CON
187:                   IC1CONbits.ICTMR = 1; // Select Timer2 as the IC1 Time base
001AAC  A8E142     BSET IC1CON, #7
188:                   IC1CONbits.ICI = 0b01; // Interrupt on every second capture event
001AAE  800A11     MOV IC1CON, W1
001AB0  2FF9F0     MOV #0xFF9F, W0
001AB2  608080     AND W1, W0, W1
001AB4  200200     MOV #0x20, W0
001AB6  708000     IOR W1, W0, W0
001AB8  880A10     MOV W0, IC1CON
189:                   IC1CONbits.ICM = 0b001; // Generate capture event on every Rising edge
001ABA  800A11     MOV IC1CON, W1
001ABC  2FFF80     MOV #0xFFF8, W0
001ABE  608000     AND W1, W0, W0
001AC0  A00000     BSET W0, #0
001AC2  880A10     MOV W0, IC1CON
190:               
191:                   // Enable Capture Interrupt And Timer2
192:                   IPC0bits.IC1IP = INPUT_CAPTURE_LEVEL; // Setup IC1 interrupt priority level
001AC4  800521     MOV IPC0, W1
001AC6  200700     MOV #0x70, W0
001AC8  708000     IOR W1, W0, W0
001ACA  880520     MOV W0, IPC0
193:                   IFS0bits.IC1IF = 0; // Clear IC1 Interrupt Status Flag
001ACC  A92084     BCLR IFS0, #1
194:                   IEC0bits.IC1IE = 1; // Enable IC1 interrupt
001ACE  A82094     BSET IEC0, #1
195:               }
001AD0  FA8000     ULNK
001AD2  060000     RETURN
196:               
197:               void InitIC2(void) {
001AD4  FA0000     LNK #0x0
198:                   // Initialize Capture Module
199:                   IC2CONbits.ICM = 0b00; // Disable Input Capture 2 module
001AD6  800A31     MOV IC2CON, W1
001AD8  2FFF80     MOV #0xFFF8, W0
001ADA  608000     AND W1, W0, W0
001ADC  880A30     MOV W0, IC2CON
200:                   IC2CONbits.ICTMR = 1; // Select Timer2 as the IC1 Time base
001ADE  A8E146     BSET IC2CON, #7
201:                   IC2CONbits.ICI = 0b01; // Interrupt on every second capture event
001AE0  800A31     MOV IC2CON, W1
001AE2  2FF9F0     MOV #0xFF9F, W0
001AE4  608080     AND W1, W0, W1
001AE6  200200     MOV #0x20, W0
001AE8  708000     IOR W1, W0, W0
001AEA  880A30     MOV W0, IC2CON
202:                   IC2CONbits.ICM = 0b001; // Generate capture event on every Rising edge
001AEC  800A31     MOV IC2CON, W1
001AEE  2FFF80     MOV #0xFFF8, W0
001AF0  608000     AND W1, W0, W0
001AF2  A00000     BSET W0, #0
001AF4  880A30     MOV W0, IC2CON
203:               
204:                   // Enable Capture Interrupt And Timer2
205:                   IPC1bits.IC2IP = INPUT_CAPTURE_LEVEL; // Setup IC2 interrupt priority level
001AF6  800531     MOV IPC1, W1
001AF8  200700     MOV #0x70, W0
001AFA  708000     IOR W1, W0, W0
001AFC  880530     MOV W0, IPC1
206:                   IFS0bits.IC2IF = 0; // Clear IC2 Interrupt Status Flag
001AFE  A9A084     BCLR IFS0, #5
207:                   IEC0bits.IC2IE = 1; // Enable IC2 interrupt
001B00  A8A094     BSET IEC0, #5
208:               }
001B02  FA8000     ULNK
001B04  060000     RETURN
209:               
210:               void InitTimer1(void) {
001B06  FA0000     LNK #0x0
211:                   //T1CON = 10100000 00000000
212:                   T1CONbits.TON = 0; // Disable Timer
001B08  A9E105     BCLR 0x105, #7
213:                   T1CONbits.TSIDL = 1; // Stop in Idle Mode bit
001B0A  A8A105     BSET 0x105, #5
214:                   T1CONbits.TGATE = 0; // Disable Gated Timer mode
001B0C  A9C104     BCLR T1CON, #6
215:                   T1CONbits.TCKPS = 0b00; // Select 1:1 Prescaler
001B0E  800821     MOV T1CON, W1
001B10  2FFCF0     MOV #0xFFCF, W0
001B12  608000     AND W1, W0, W0
001B14  880820     MOV W0, T1CON
216:                   T1CONbits.TSYNC = 0; // Disable Synchronization
001B16  A94104     BCLR T1CON, #2
217:                   T1CONbits.TCS = 0; // Select internal clock source
001B18  A92104     BCLR T1CON, #1
218:                   TMR1 = 0x00; // Clear timer register
001B1A  EB0000     CLR W0
001B1C  880800     MOV W0, TMR1
219:                   PR1 = TMR1_VALUE; // Load the period value
001B1E  29C400     MOV #0x9C40, W0
001B20  880810     MOV W0, PR1
220:               
221:                   IPC0bits.T1IP = SYS_TIMER_LEVEL; // Set Timer 1 Interrupt Priority Level
001B22  800521     MOV IPC0, W1
001B24  28FFF0     MOV #0x8FFF, W0
001B26  608080     AND W1, W0, W1
001B28  250000     MOV #0x5000, W0
001B2A  708000     IOR W1, W0, W0
001B2C  880520     MOV W0, IPC0
222:                   IFS0bits.T1IF = 0; // Clear Timer 1 Interrupt Flag
001B2E  A96084     BCLR IFS0, #3
223:                   IEC0bits.T1IE = 1; // Enable Timer1 interrupt
001B30  A86094     BSET IEC0, #3
224:               
225:                   T1CONbits.TON = 1; // Start Timer
001B32  A8E105     BSET 0x105, #7
226:               }
001B34  FA8000     ULNK
001B36  060000     RETURN
227:               
228:               void InitTimer2(void) {
001B38  FA0000     LNK #0x0
229:                   //T2CON = 10100000 00000000
230:                   T2CONbits.TON = 0; // Disable Timer
001B3A  A9E111     BCLR 0x111, #7
231:                   T2CONbits.TSIDL = 1; // Stop in Idle Mode bit
001B3C  A8A111     BSET 0x111, #5
232:                   T2CONbits.TGATE = 0; // Disable Gated Timer mode
001B3E  A9C110     BCLR T2CON, #6
233:                   T2CONbits.TCKPS = 0b00; // Select 1:1 Prescaler
001B40  800881     MOV T2CON, W1
001B42  2FFCF0     MOV #0xFFCF, W0
001B44  608000     AND W1, W0, W0
001B46  880880     MOV W0, T2CON
234:                   T2CONbits.TCS = 0; // Select internal clock source
001B48  A92110     BCLR T2CON, #1
235:                   TMR2 = 0x00; // Clear timer register
001B4A  EB0000     CLR W0
001B4C  880830     MOV W0, TMR2
236:                   PR2 = TMR2_VALUE; // Load the period value
001B4E  EB8000     SETM W0
001B50  880860     MOV W0, PR2
237:               
238:                   IPC1bits.T2IP = PWM_TIMER_LEVEL; // Set Timer 1 Interrupt Priority Level
001B52  800531     MOV IPC1, W1
001B54  270000     MOV #0x7000, W0
001B56  708000     IOR W1, W0, W0
001B58  880530     MOV W0, IPC1
239:                   IFS0bits.T2IF = 0; // Clear Timer 1 Interrupt Flag
001B5A  A9E084     BCLR IFS0, #7
240:                   IEC0bits.T2IE = 1; // Enable Timer1 interrupt
001B5C  A8E094     BSET IEC0, #7
241:               
242:                   T2CONbits.TON = 1; // Start Timer
001B5E  A8E111     BSET 0x111, #7
243:               }
001B60  FA8000     ULNK
001B62  060000     RETURN
244:               
245:               void InitInterrupts(void) {
001B64  FA0000     LNK #0x0
246:                   //For PID velocity control
247:                   IPC0bits.OC1IP = VEL_PID_LEVEL; // Set Output Compare Channel 1 Priority Level
001B66  800521     MOV IPC0, W1
001B68  2F8FF0     MOV #0xF8FF, W0
001B6A  608080     AND W1, W0, W1
001B6C  203000     MOV #0x300, W0
001B6E  708000     IOR W1, W0, W0
001B70  880520     MOV W0, IPC0
248:                   IFS0bits.OC1IF = 0; // Clear Output Compare Channel 1 Interrupt Flag
001B72  A94084     BCLR IFS0, #2
249:                   IEC0bits.OC1IE = 1; // Enable Output Compare Channel 1 interrupt
001B74  A84094     BSET IEC0, #2
250:               
251:                   //For Parsing UART message
252:                   IPC1bits.OC2IP = RX_PARSER_LEVEL; // Set Output Compare Channel 2 Priority Level
001B76  800531     MOV IPC1, W1
001B78  2F8FF0     MOV #0xF8FF, W0
001B7A  608080     AND W1, W0, W1
001B7C  201000     MOV #0x100, W0
001B7E  708000     IOR W1, W0, W0
001B80  880530     MOV W0, IPC1
253:                   IFS0bits.OC2IF = 0; // Clear Output Compare Channel 2 Interrupt Flag
001B82  A9C084     BCLR IFS0, #6
254:                   IEC0bits.OC2IE = 1; // Enable Output Compare Channel 2 interrupt
001B84  A8C094     BSET IEC0, #6
255:               
256:                   // For dead reckoning
257:                   IPC15bits.RTCIP = DEAD_RECK_LEVEL; // Set RTC Priority Level
001B86  800611     MOV IPC15, W1
001B88  2F8FF0     MOV #0xF8FF, W0
001B8A  608080     AND W1, W0, W1
001B8C  202000     MOV #0x200, W0
001B8E  708000     IOR W1, W0, W0
001B90  880610     MOV W0, IPC15
258:                   IFS3bits.RTCIF = 0; // Clear RTC Interrupt Flag
001B92  A9C08B     BCLR 0x8B, #6
259:                   DEAD_RECK_ENABLE = 1; // Enable RTC interrupt
001B94  A8C09B     BSET 0x9B, #6
260:               }
001B96  FA8000     ULNK
001B98  060000     RETURN
261:               
262:               void InitUART1(void) {
001B9A  FA0000     LNK #0x0
263:                   U1MODEbits.STSEL = 0; // 1-stop bit
001B9C  A90220     BCLR U1MODE, #0
264:                   U1MODEbits.PDSEL = 0; // No Parity, 8-data bits
001B9E  801101     MOV U1MODE, W1
001BA0  2FFF90     MOV #0xFFF9, W0
001BA2  608000     AND W1, W0, W0
001BA4  881100     MOV W0, U1MODE
265:                   U1MODEbits.ABAUD = 0; // Auto-Baud Disabled
001BA6  A9A220     BCLR U1MODE, #5
266:                   U1MODEbits.BRGH = 0; // Low Speed mode
001BA8  A96220     BCLR U1MODE, #3
267:               
268:                   U1BRG = BRGVAL; // BAUD Rate Setting on System.h
001BAA  2002A0     MOV #0x2A, W0
001BAC  881140     MOV W0, U1BRG
269:               
270:                   U1STAbits.UTXISEL0 = 0; // Interrupt after one Tx character is transmitted
001BAE  A9A223     BCLR 0x223, #5
271:                   U1STAbits.UTXISEL1 = 0;
001BB0  A9E223     BCLR 0x223, #7
272:               
273:                   IEC0bits.U1TXIE = 0; // Disable UART Tx interrupt
001BB2  A98095     BCLR 0x95, #4
274:                   U1STAbits.URXISEL = 0; // Interrupt after one RX character is received
001BB4  801111     MOV U1STA, W1
001BB6  2FF3F0     MOV #0xFF3F, W0
001BB8  608000     AND W1, W0, W0
001BBA  881110     MOV W0, U1STA
275:               
276:                   U1MODEbits.UARTEN = 1; // Enable UART
001BBC  A8E221     BSET 0x221, #7
277:                   U1STAbits.UTXEN = 1; // Enable UART Tx
001BBE  A84223     BSET 0x223, #2
278:               
279:                   IEC4bits.U1EIE = 0;
001BC0  A9209C     BCLR IEC4, #1
280:                   IPC2bits.U1RXIP = UART_RX_LEVEL; // Set UART Rx Interrupt Priority Level
001BC2  800541     MOV IPC2, W1
001BC4  28FFF0     MOV #0x8FFF, W0
001BC6  608080     AND W1, W0, W1
001BC8  260000     MOV #0x6000, W0
001BCA  708000     IOR W1, W0, W0
001BCC  880540     MOV W0, IPC2
281:                   IFS0bits.U1RXIF = 0; // Reset RX interrupt flag
001BCE  A96085     BCLR 0x85, #3
282:                   IEC0bits.U1RXIE = 1; // Enable RX interrupt
001BD0  A86095     BSET 0x95, #3
283:               }
001BD2  FA8000     ULNK
001BD4  060000     RETURN
284:               
285:               void InitDMA0(void) {
001BD6  FA0000     LNK #0x0
286:                   DMA0CNT = TOT_ADC_BUFF - 1; // 64 DMA request
001BD8  2007F0     MOV #0x7F, W0
001BDA  881C50     MOV W0, DMA0CNT
287:                   DMA0REQ = 13; // Select ADC1 as DMA Request source
001BDC  2000D0     MOV #0xD, W0
001BDE  881C10     MOV W0, DMA0REQ
288:               
289:                   DMA0CONbits.AMODE = 2; // Peripheral Indirect Addressing mode
001BE0  801C01     MOV DMA0CON, W1
001BE2  2FFCF0     MOV #0xFFCF, W0
001BE4  608080     AND W1, W0, W1
001BE6  200200     MOV #0x20, W0
001BE8  708000     IOR W1, W0, W0
001BEA  881C00     MOV W0, DMA0CON
290:                   DMA0CONbits.MODE = 0; // Continuous
001BEC  801C01     MOV DMA0CON, W1
001BEE  2FFFC0     MOV #0xFFFC, W0
001BF0  608000     AND W1, W0, W0
001BF2  881C00     MOV W0, DMA0CON
291:               
292:                   DMA0STA = __builtin_dmaoffset(AdcBuffer);
001BF4  206000     MOV #0x600, W0
001BF6  881C20     MOV W0, DMA0STA
293:                   DMA0PAD = (volatile unsigned int) &ADC1BUF0; // Point DMA to ADC1BUF0
001BF8  203000     MOV #0x300, W0
001BFA  881C40     MOV W0, DMA0PAD
294:               
295:                   IFS0bits.DMA0IF = 0; // Clear DMA Interrupt Flag
001BFC  A98084     BCLR IFS0, #4
296:                   IPC1bits.DMA0IP = ADC_DMA_LEVEL; // Set DMA Interrupt Priority Level
001BFE  800531     MOV IPC1, W1
001C00  2FFF80     MOV #0xFFF8, W0
001C02  608000     AND W1, W0, W0
001C04  B30060     IOR #0x6, W0
001C06  880530     MOV W0, IPC1
297:                   IEC0bits.DMA0IE = 1; // Enable DMA interrupt
001C08  A88094     BSET IEC0, #4
298:                   DMA0CONbits.CHEN = 1; // Enable DMA
001C0A  A8E381     BSET 0x381, #7
299:               }
001C0C  FA8000     ULNK
001C0E  060000     RETURN
300:               
301:               void InitDMA1(void) {
001C10  FA0000     LNK #0x0
302:                   //DMA1CON = 0x2001;			// One-Shot, Post-Increment, RAM-to-Peripheral
303:               
304:                   DMA1CONbits.CHEN = 0;
001C12  A9E38D     BCLR 0x38D, #7
305:                   DMA1CONbits.SIZE = 1;
001C14  A8C38D     BSET 0x38D, #6
306:                   DMA1CONbits.DIR = 1;
001C16  A8A38D     BSET 0x38D, #5
307:                   DMA1CONbits.HALF = 0;
001C18  A9838D     BCLR 0x38D, #4
308:                   DMA1CONbits.NULLW = 0;
001C1A  A9638D     BCLR 0x38D, #3
309:                   DMA1CONbits.AMODE = 0;
001C1C  801C61     MOV DMA1CON, W1
001C1E  2FFCF0     MOV #0xFFCF, W0
001C20  608000     AND W1, W0, W0
001C22  881C60     MOV W0, DMA1CON
310:                   DMA1CONbits.MODE = 1;
001C24  801C61     MOV DMA1CON, W1
001C26  2FFFC0     MOV #0xFFFC, W0
001C28  608000     AND W1, W0, W0
001C2A  A00000     BSET W0, #0
001C2C  881C60     MOV W0, DMA1CON
311:               
312:               
313:               
314:                   DMA1CNT = MAX_TX_BUFF - 1; // 32 DMA requests
001C2E  200C70     MOV #0xC7, W0
001C30  881CB0     MOV W0, DMA1CNT
315:                   DMA1REQ = 0x000c; // Select UART1 Transmitter
001C32  2000C0     MOV #0xC, W0
001C34  881C70     MOV W0, DMA1REQ
316:               
317:                   DMA1STA = __builtin_dmaoffset(BufferTx);
001C36  207000     MOV #0x700, W0
001C38  881C80     MOV W0, DMA1STA
318:                   DMA1PAD = (volatile unsigned int) &U1TXREG;
001C3A  202240     MOV #0x224, W0
001C3C  881CA0     MOV W0, DMA1PAD
319:               
320:                   IPC3bits.DMA1IP = UART_TX_LEVEL; // Set DMA Interrupt Priority Level
001C3E  800551     MOV IPC3, W1
001C40  2F8FF0     MOV #0xF8FF, W0
001C42  608080     AND W1, W0, W1
001C44  201000     MOV #0x100, W0
001C46  708000     IOR W1, W0, W0
001C48  880550     MOV W0, IPC3
321:                   IFS0bits.DMA1IF = 0; // Clear DMA Interrupt Flag
001C4A  A9C085     BCLR 0x85, #6
322:                   IEC0bits.DMA1IE = 1; // Enable DMA interrupt
001C4C  A8C095     BSET 0x95, #6
323:               }
001C4E  FA8000     ULNK
001C50  060000     RETURN
324:               
325:               void InitADC(void) {
001C52  FA0000     LNK #0x0
326:                   AD1CON1bits.FORM = 0; // Data Output Format: Integer
001C54  801901     MOV AD1CON1, W1
001C56  2FCFF0     MOV #0xFCFF, W0
001C58  608000     AND W1, W0, W0
001C5A  881900     MOV W0, AD1CON1
327:                   AD1CON1bits.SSRC = 3; // Sample Clock Source: Internal counter sampling and starts convertions (auto-convert)
001C5C  801901     MOV AD1CON1, W1
001C5E  2FF1F0     MOV #0xFF1F, W0
001C60  608080     AND W1, W0, W1
001C62  200600     MOV #0x60, W0
001C64  708000     IOR W1, W0, W0
001C66  881900     MOV W0, AD1CON1
328:                   AD1CON1bits.ASAM = 1; // ADC Sample Control: Sampling begins immediately after conversion
001C68  A84320     BSET AD1CON1, #2
329:                   AD1CON1bits.AD12B = 0; // 10-bit ADC operation
001C6A  A94321     BCLR 0x321, #2
330:                   AD1CON1bits.ADSIDL = 1; // stop in idle
001C6C  A8A321     BSET 0x321, #5
331:                   AD1CON1bits.SIMSAM = 1; // CH0 CH1 sampled simultaneously
001C6E  A86320     BSET AD1CON1, #3
332:               
333:                   AD1CON2bits.CSCNA = 0; // Input scan: Do not scan inputs
001C70  A94323     BCLR 0x323, #2
334:                   AD1CON2bits.CHPS = 1; // Convert CH0 and CH1
001C72  801911     MOV AD1CON2, W1
001C74  2FCFF0     MOV #0xFCFF, W0
001C76  608080     AND W1, W0, W1
001C78  201000     MOV #0x100, W0
001C7A  708000     IOR W1, W0, W0
001C7C  881910     MOV W0, AD1CON2
335:                   AD1CON2bits.BUFM = 0; // filling buffer from start address
001C7E  A92322     BCLR AD1CON2, #1
336:                   AD1CON2bits.ALTS = 0; // sample A
001C80  A90322     BCLR AD1CON2, #0
337:               
338:                   AD1CON3bits.ADRC = 0; // ADC Clock is derived from Systems Clock
001C82  A9E325     BCLR 0x325, #7
339:                   AD1CON3bits.SAMC = 0b11111; // 31 Tad auto sample time
001C84  801921     MOV AD1CON3, W1
001C86  21F000     MOV #0x1F00, W0
001C88  708000     IOR W1, W0, W0
001C8A  881920     MOV W0, AD1CON3
340:                   AD1CON3bits.ADCS = ADC_BUFF - 1; // ADC Conversion Clock Tad=Tcy*(ADCS+1)= (1/40M)*64 = 1.6us (625Khz)
001C8C  B3C3F0     MOV #0x3F, W0
001C8E  B7E324     MOV.B WREG, AD1CON3
341:                   // ADC Conversion Time for 10-bit Tc=12*Tab = 19.2us
342:               
343:                   AD1CON1bits.ADDMABM = 0; // DMA buffers are built in scatter/gather mode
001C90  A98321     BCLR 0x321, #4
344:                   AD1CON2bits.SMPI = 0b0001; // number of DMA buffers -1
001C92  801911     MOV AD1CON2, W1
001C94  2FFC30     MOV #0xFFC3, W0
001C96  608000     AND W1, W0, W0
001C98  A02000     BSET W0, #2
001C9A  881910     MOV W0, AD1CON2
345:                   AD1CON4bits.DMABL = 0b110; // 64 word DMA buffer for each analog input
001C9C  801991     MOV AD1CON4, W1
001C9E  2FFF80     MOV #0xFFF8, W0
001CA0  608000     AND W1, W0, W0
001CA2  B30060     IOR #0x6, W0
001CA4  881990     MOV W0, AD1CON4
346:               
347:                   AD1CHS123bits.CH123NB = 0; // don't care -> sample B
001CA6  801931     MOV AD1CHS123, W1
001CA8  2F9FF0     MOV #0xF9FF, W0
001CAA  608000     AND W1, W0, W0
001CAC  881930     MOV W0, AD1CHS123
348:                   AD1CHS123bits.CH123SB = 0; // don't care -> sample B
001CAE  A90327     BCLR 0x327, #0
349:                   AD1CHS123bits.CH123NA = 0; // CH1,2,3 negative input = Vrefl
001CB0  801931     MOV AD1CHS123, W1
001CB2  2FFF90     MOV #0xFFF9, W0
001CB4  608000     AND W1, W0, W0
001CB6  881930     MOV W0, AD1CHS123
350:                   AD1CHS123bits.CH123SA = 0; // CH1 = AN0, CH2=AN1, CH3=AN2
001CB8  A90326     BCLR AD1CHS123, #0
351:               
352:                   AD1CHS0bits.CH0NB = 0; // don't care -> sample B
001CBA  A9E329     BCLR 0x329, #7
353:                   AD1CHS0bits.CH0SB = 0; // don't care -> sample B
001CBC  801941     MOV AD1CHS0, W1
001CBE  2E0FF0     MOV #0xE0FF, W0
001CC0  608000     AND W1, W0, W0
001CC2  881940     MOV W0, AD1CHS0
354:                   AD1CHS0bits.CH0NA = 0; // CH0 neg -> Vrefl
001CC4  A9E328     BCLR AD1CHS0, #7
355:                   AD1CHS0bits.CH0SA = 1; // CH0 pos -> AN1
001CC6  801941     MOV AD1CHS0, W1
001CC8  2FFE00     MOV #0xFFE0, W0
001CCA  608000     AND W1, W0, W0
001CCC  A00000     BSET W0, #0
001CCE  881940     MOV W0, AD1CHS0
356:               
357:                   AD1PCFGL = 0xFFFF; // set all Analog ports as digital
001CD0  EB8000     SETM W0
001CD2  881960     MOV W0, AD1PCFGL
358:                   AD1PCFGLbits.PCFG0 = 0; // AN0
001CD4  A9032C     BCLR AD1PCFGL, #0
359:                   AD1PCFGLbits.PCFG1 = 0; // AN1
001CD6  A9232C     BCLR AD1PCFGL, #1
360:               
361:                   IFS0bits.AD1IF = 0; // Clear the A/D interrupt flag bit
001CD8  A9A085     BCLR 0x85, #5
362:                   IEC0bits.AD1IE = 0; // Do Not Enable A/D interrupt
001CDA  A9A095     BCLR 0x95, #5
363:                   AD1CON1bits.ADON = 1; // module on
001CDC  A8E321     BSET 0x321, #7
364:               }
001CDE  FA8000     ULNK
001CE0  060000     RETURN
---  C:/Users/Raffaello/Dropbox/MicrochipProject/dsPIC33MotionControl.X/serial.c  -----------------------
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                #include <stdint.h>        /* Includes uint16_t definition   */
17:                #include <stdbool.h>       /* Includes true/false definition */
18:                
19:                #include "serial.h"
20:                
21:                /******************************************************************************/
22:                /* Global Variable Declaration                                                */
23:                /******************************************************************************/
24:                
25:                int (*pkg_parse) (unsigned char inchar) = &pkg_header;
26:                unsigned char BufferTx[MAX_TX_BUFF] __attribute__((space(dma)));
27:                packet_t receive_pkg;
28:                unsigned int index_data = 0;
29:                
30:                /******************************************************************************/
31:                /* Comunication Functions                                                     */
32:                /******************************************************************************/
33:                
34:                /* Data structure:
35:                 * ------------------------------------------------
36:                 * | HEADER | LENGTH |       DATA           | CKS |
37:                 * ------------------------------------------------
38:                 *     1        2             3 -> n          n+1
39:                 */
40:                
41:                int decode_pkgs(unsigned char rxchar) {
001EF4  FA0002     LNK #0x2
001EF6  784F00     MOV.B W0, [W14]
42:                    return (*pkg_parse)(rxchar);
001EF8  804E41     MOV 0x9C8, W1
001EFA  78401E     MOV.B [W14], W0
001EFC  010001     CALL W1
43:                }
001EFE  FA8000     ULNK
001F00  060000     RETURN
44:                
45:                int pkg_header(unsigned char rxchar) {
001F02  FA0002     LNK #0x2
001F04  784F00     MOV.B W0, [W14]
46:                    if (rxchar == HEADER) {
001F06  B3C230     MOV #0x23, W0
001F08  78409E     MOV.B [W14], W1
001F0A  50CF80     SUB.B W1, W0, [W15]
001F0C  3A0004     BRA NZ, 0x1F16
47:                        pkg_parse = &pkg_length;
001F0E  21F1E0     MOV #0x1F1E, W0
001F10  884E40     MOV W0, 0x9C8
48:                        return false;
001F12  EB0000     CLR W0
001F14  370002     BRA 0x1F1A
49:                    } else {
50:                        return pkg_error(ERROR_HEADER);
001F16  2FFFD0     MOV #0xFFFD, W0
001F18  070042     RCALL pkg_error
51:                    }
52:                }
001F1A  FA8000     ULNK
001F1C  060000     RETURN
53:                
54:                int pkg_length(unsigned char rxchar) {
001F1E  FA0002     LNK #0x2
001F20  784F00     MOV.B W0, [W14]
55:                    if (rxchar > MAX_RX_BUFF) {
001F22  B3CC80     MOV #0xC8, W0
001F24  78409E     MOV.B [W14], W1
001F26  50CF80     SUB.B W1, W0, [W15]
001F28  360003     BRA LEU, 0x1F30
56:                        return pkg_error(ERROR_LENGTH);
001F2A  2FFFC0     MOV #0xFFFC, W0
001F2C  070038     RCALL pkg_error
001F2E  370006     BRA 0x1F3C
57:                    } else {
58:                        pkg_parse = &pkg_data;
001F30  21F400     MOV #0x1F40, W0
001F32  884E40     MOV W0, 0x9C8
59:                        receive_pkg.length = rxchar;
001F34  78409E     MOV.B [W14], W1
001F36  FB8001     ZE W1, W0
001F38  884070     MOV W0, receive_pkg
60:                        return false;
001F3A  EB0000     CLR W0
61:                    }
62:                }
001F3C  FA8000     ULNK
001F3E  060000     RETURN
63:                
64:                int pkg_data(unsigned char rxchar) {
001F40  FA0006     LNK #0x6
001F42  984740     MOV.B W0, [W14+4]
65:                    int cks_clc;
66:                    if ((index_data + 1) == (receive_pkg.length + 1)) {
001F44  804E50     MOV 0x9CA, W0
001F46  E80080     INC W0, W1
001F48  804070     MOV receive_pkg, W0
001F4A  E80000     INC W0, W0
001F4C  508F80     SUB W1, W0, [W15]
001F4E  3A001C     BRA NZ, 0x1F88
67:                        pkg_parse = &pkg_header; //Restart parse serial packet
001F50  21F020     MOV #0x1F02, W0
001F52  884E40     MOV W0, 0x9C8
68:                        if ((cks_clc = pkg_checksum(receive_pkg.buffer, 0, index_data)) == rxchar) { //checksum data
001F54  804E50     MOV 0x9CA, W0
001F56  780080     MOV W0, W1
001F58  208100     MOV #0x810, W0
001F5A  780101     MOV W1, W2
001F5C  EB0080     CLR W1
001F5E  070028     RCALL pkg_checksum
001F60  FB8000     ZE W0, W0
001F62  780F00     MOV W0, [W14]
001F64  90404E     MOV.B [W14+4], W0
001F66  FB8000     ZE W0, W0
001F68  78009E     MOV [W14], W1
001F6A  508F80     SUB W1, W0, [W15]
001F6C  3A0004     BRA NZ, 0x1F76
69:                            index_data = 0; //flush index array data buffer
001F6E  EB0000     CLR W0
001F70  884E50     MOV W0, 0x9CA
70:                            return true;
001F72  200010     MOV #0x1, W0
001F74  370012     BRA 0x1F9A
71:                        } else {
72:                            bool t = pkg_error(ERROR_CKS);
001F76  2FFFA0     MOV #0xFFFA, W0
001F78  070012     RCALL pkg_error
001F7A  EA0080     NEG W0, W1
001F7C  708000     IOR W1, W0, W0
001F7E  DE004F     LSR W0, #15, W0
001F80  984720     MOV.B W0, [W14+2]
73:                            return t;
001F82  90402E     MOV.B [W14+2], W0
001F84  FB8000     ZE W0, W0
001F86  370009     BRA 0x1F9A
74:                        }
75:                    } else {
76:                        receive_pkg.buffer[index_data] = rxchar;
001F88  804E51     MOV 0x9CA, W1
001F8A  208100     MOV #0x810, W0
001F8C  408000     ADD W1, W0, W0
001F8E  9040CE     MOV.B [W14+4], W1
001F90  784801     MOV.B W1, [W0]
77:                        index_data++;
001F92  804E50     MOV 0x9CA, W0
001F94  E80000     INC W0, W0
001F96  884E50     MOV W0, 0x9CA
78:                        return false;
001F98  EB0000     CLR W0
79:                    }
80:                }
001F9A  FA8000     ULNK
001F9C  060000     RETURN
81:                
82:                int pkg_error(int error) {
001F9E  FA0002     LNK #0x2
001FA0  780F00     MOV W0, [W14]
83:                    // TODO complete task error
84:                    index_data = 0;
001FA2  EB0000     CLR W0
001FA4  884E50     MOV W0, 0x9CA
85:                    pkg_parse = &pkg_header; //Restart parse serial packet
001FA6  21F020     MOV #0x1F02, W0
001FA8  884E40     MOV W0, 0x9C8
86:                    return error;
001FAA  78001E     MOV [W14], W0
87:                }
001FAC  FA8000     ULNK
001FAE  060000     RETURN
88:                
89:                unsigned char pkg_checksum(volatile unsigned char* Buffer, int FirstIndx, int LastIndx) {
001FB0  FA000A     LNK #0xA
001FB2  980720     MOV W0, [W14+4]
001FB4  980731     MOV W1, [W14+6]
001FB6  980742     MOV W2, [W14+8]
90:                    unsigned char ChkSum = 0;
001FB8  EB4000     CLR.B W0
001FBA  784F00     MOV.B W0, [W14]
91:                    int ChkCnt;
92:                    for (ChkCnt = FirstIndx; ChkCnt < LastIndx; ChkCnt++) {
001FBC  90003E     MOV [W14+6], W0
001FBE  980710     MOV W0, [W14+2]
001FC0  370008     BRA 0x1FD2
001FCC  90001E     MOV [W14+2], W0
001FCE  E80000     INC W0, W0
001FD0  980710     MOV W0, [W14+2]
001FD2  90009E     MOV [W14+2], W1
001FD4  90004E     MOV [W14+8], W0
001FD6  508F80     SUB W1, W0, [W15]
001FD8  35FFF4     BRA LT, 0x1FC2
93:                        ChkSum += Buffer[ChkCnt];
001FC2  90001E     MOV [W14+2], W0
001FC4  9000AE     MOV [W14+4], W1
001FC6  408000     ADD W1, W0, W0
001FC8  784010     MOV.B [W0], W0
001FCA  404F1E     ADD.B W0, [W14], [W14]
94:                    }
95:                    return ChkSum;
001FDA  78401E     MOV.B [W14], W0
96:                }
001FDC  FA8000     ULNK
001FDE  060000     RETURN
97:                
98:                /**
99:                 * Write a string to the serial device.
100:                * \param s string to write
101:                * \throws boost::system::system_error on failure
102:                */
103:               void pkg_send(packet_t packet) {
001FE0  FA0002     LNK #0x2
001FE2  781F88     MOV W8, [W15++]
104:                   /* on packet:
105:                    * -------------------------- ---------------------------- -----------------------
106:                    * | Length | CMD | DATA ... | Length | CMD | INFORMATION |Length | CMD | ... ... |
107:                    * -------------------------- ---------------------------- -----------------------
108:                    *    1        2 -> length    length+1 length+2 length+3   ....
109:                    */
110:               
111:                   int i;
112:                   BufferTx[0] = HEADER;
001FE4  247001     MOV #0x4700, W1
001FE6  B3C230     MOV #0x23, W0
001FE8  784880     MOV.B W0, [W1]
113:                   BufferTx[1] = packet.length;
001FEA  97107E     MOV [W14-210], W0
001FEC  784000     MOV.B W0, W0
001FEE  247011     MOV #0x4701, W1
001FF0  784880     MOV.B W0, [W1]
114:               
115:                   for (i = 0; i < packet.length; i++) {
001FF2  EB0000     CLR W0
001FF4  780F00     MOV W0, [W14]
001FF6  370008     BRA 0x2008
002006  E80F1E     INC [W14], [W14]
002008  78009E     MOV [W14], W1
00200A  97107E     MOV [W14-210], W0
00200C  508F80     SUB W1, W0, [W15]
00200E  39FFF4     BRA NC, 0x1FF8
116:                       BufferTx[i + HEAD_PKG] = packet.buffer[i];
001FF8  E8809E     INC2 [W14], W1
001FFA  E8801E     INC2 [W14], W0
001FFC  570166     SUB W14, #0x6, W2
001FFE  410000     ADD W2, W0, W0
002000  967040     MOV.B [W0-204], W0
002002  247002     MOV #0x4700, W2
002004  78F100     MOV.B W0, [W2+W1]
117:                   }
118:               
119:                   BufferTx[packet.length + HEAD_PKG] = pkg_checksum(BufferTx, HEAD_PKG, packet.length + HEAD_PKG);
002010  97107E     MOV [W14-210], W0
002012  E88400     INC2 W0, W8
002014  97107E     MOV [W14-210], W0
002016  E88000     INC2 W0, W0
002018  780080     MOV W0, W1
00201A  247000     MOV #0x4700, W0
00201C  780101     MOV W1, W2
00201E  200021     MOV #0x2, W1
002020  07FFC7     RCALL pkg_checksum
002022  247001     MOV #0x4700, W1
002024  7C7080     MOV.B W0, [W1+W8]
120:               
121:                   DMA1CNT = (HEAD_PKG + packet.length + 1) - 1; // # of DMA requests
002026  97107E     MOV [W14-210], W0
002028  E88000     INC2 W0, W0
00202A  881CB0     MOV W0, DMA1CNT
122:                   DMA1CONbits.CHEN = 1; // Enable DMA1 Channel
00202C  A8E38D     BSET 0x38D, #7
123:                   DMA1REQbits.FORCE = 1; // Manual mode: Kick-start the 1st transfer
00202E  A8E38F     BSET 0x38F, #7
124:               }
002030  78044F     MOV [--W15], W8
002032  FA8000     ULNK
002034  060000     RETURN
---  C:/Users/Raffaello/Dropbox/MicrochipProject/dsPIC33MotionControl.X/parsing_packet.c  ---------------
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                #include <stdint.h>        /* Includes uint16_t definition   */
17:                #include <stdbool.h>       /* Includes true/false definition */
18:                #include <string.h>
19:                
20:                #include "parsing_packet.h"
21:                
22:                #include "serial.h"
23:                
24:                #include "motors_PID.h"
25:                #include "user.h"
26:                #include "system.h"
27:                
28:                
29:                // From Interrupt
30:                extern volatile process_t time, priority, frequency;
31:                
32:                // From serial
33:                extern packet_t receive_pkg;
34:                
35:                // From motors PID
36:                extern parameter_t parameter;
37:                extern constraint_t constraint;
38:                extern velocity_t vel_rif, vel_mis;
39:                extern pid_control_t pid_left, pid_right;
40:                extern enable_motor_t enable_motors;
41:                extern motor_t motor_left, motor_right;
42:                
43:                // From high level control
44:                extern coordinate_t coordinate;
45:                
46:                
47:                /******************************************************************************/
48:                /* Parsing functions                                                          */
49:                
50:                /******************************************************************************/
51:                
52:                int parse_packet(void) {
000B36  FA0268     LNK #0x268
53:                    int i;
54:                    unsigned int t = TMR1; // Timing function
000B38  800800     MOV TMR1, W0
000B3A  980720     MOV W0, [W14+4]
55:                    packet_t send, packet;
56:                    send.length = 0;
000B3C  EB0000     CLR W0
000B3E  980730     MOV W0, [W14+6]
57:                    memcpy(&packet, &receive_pkg, sizeof (packet));
000B40  200D20     MOV #0xD2, W0
000B42  40000E     ADD W0, W14, W0
000B44  200CC2     MOV #0xCC, W2
000B46  2080E1     MOV #0x80E, W1
000B48  07FFEE     RCALL _memcpy
58:                    for (i = 0; i < packet.length; i++) {
000B4A  EB0000     CLR W0
000B4C  780F00     MOV W0, [W14]
000B4E  370058     BRA 0xC00
000BFE  E80F1E     INC [W14], [W14]
000C00  78009E     MOV [W14], W1
000C02  90A81E     MOV [W14+210], W0
000C04  508F80     SUB W1, W0, [W15]
000C06  39FFA4     BRA NC, 0xB50
59:                        unsigned char option;
60:                        if (packet.buffer[i] > 1)
000B50  E8801E     INC2 [W14], W0
000B52  470000     ADD W14, W0, W0
000B54  91D020     MOV.B [W0+210], W0
000B56  504FE1     SUB.B W0, #0x1, [W15]
000B58  360003     BRA LEU, 0xB60
61:                            option = CHANGE;
000B5A  B3C430     MOV #0x43, W0
000B5C  984720     MOV.B W0, [W14+2]
000B5E  370005     BRA 0xB6A
62:                        else
63:                            option = packet.buffer[i + 2];
000B60  E8801E     INC2 [W14], W0
000B62  E88000     INC2 W0, W0
000B64  470000     ADD W14, W0, W0
000B66  91D0A0     MOV.B [W0+210], W1
000B68  984721     MOV.B W1, [W14+2]
64:                        switch (option) {
000B6A  90402E     MOV.B [W14+2], W0
000B6C  FB8000     ZE W0, W0
000B6E  B90161     MUL.SU W0, #1, W2
000B70  2FFBD0     MOV #0xFFBD, W0
000B72  2FFFF1     MOV #0xFFFF, W1
000B74  400002     ADD W0, W2, W0
000B76  488083     ADDC W1, W3, W1
000B78  2000F2     MOV #0xF, W2
000B7A  200003     MOV #0x0, W3
000B7C  500F82     SUB W0, W2, [W15]
000B7E  588F83     SUBB W1, W3, [W15]
000B80  3E0035     BRA GTU, 0xBEC
000B82  016000     BRA W0
000B84  37000F     BRA 0xBA4
000B86  370034     BRA 0xBF0
000B88  370033     BRA 0xBF0
000B8A  370032     BRA 0xBF0
000B8C  370031     BRA 0xBF0
000B8E  370030     BRA 0xBF0
000B90  37002F     BRA 0xBF0
000B92  37002E     BRA 0xBF0
000B94  370019     BRA 0xBC8
000B96  37002C     BRA 0xBF0
000B98  37002B     BRA 0xBF0
000B9A  370016     BRA 0xBC8
000B9C  370029     BRA 0xBF0
000B9E  370028     BRA 0xBF0
000BA0  370027     BRA 0xBF0
000BA2  370012     BRA 0xBC8
65:                            case CHANGE:
66:                                decode_single_pkg(&send, packet.buffer[i + 1], packet.buffer, i + 2);
000BA4  E8801E     INC2 [W14], W0
000BA6  780180     MOV W0, W3
000BA8  E8001E     INC [W14], W0
000BAA  E88000     INC2 W0, W0
000BAC  470000     ADD W14, W0, W0
000BAE  91D020     MOV.B [W0+210], W0
000BB0  2019E5     MOV #0x19E, W5
000BB2  42828E     ADD W5, W14, W5
000BB4  200D21     MOV #0xD2, W1
000BB6  40808E     ADD W1, W14, W1
000BB8  E88101     INC2 W1, W2
000BBA  4700E6     ADD W14, #0x6, W1
000BBC  780203     MOV W3, W4
000BBE  780182     MOV W2, W3
000BC0  784100     MOV.B W0, W2
000BC2  780005     MOV W5, W0
000BC4  070030     RCALL decode_single_pkg
67:                                break;
000BC6  370015     BRA 0xBF2
68:                            case REQUEST:
69:                            case ACK:
70:                            case NACK:
71:                                addPacket(&send, packet.buffer[i + 1], packet.buffer[i + 2], NULL);
000BC8  E8801E     INC2 [W14], W0
000BCA  E88000     INC2 W0, W0
000BCC  470000     ADD W14, W0, W0
000BCE  91D0A0     MOV.B [W0+210], W1
000BD0  E8001E     INC [W14], W0
000BD2  E88000     INC2 W0, W0
000BD4  470000     ADD W14, W0, W0
000BD6  91D020     MOV.B [W0+210], W0
000BD8  2019E5     MOV #0x19E, W5
000BDA  42828E     ADD W5, W14, W5
000BDC  470366     ADD W14, #0x6, W6
000BDE  EB0200     CLR W4
000BE0  784181     MOV.B W1, W3
000BE2  784100     MOV.B W0, W2
000BE4  780086     MOV W6, W1
000BE6  780005     MOV W5, W0
000BE8  07015D     RCALL addPacket
72:                                break;
000BEA  370003     BRA 0xBF2
73:                            default:
74:                                break;
000BEC  000000     NOP
000BEE  370001     BRA 0xBF2
000BF0  000000     NOP
75:                        }
76:                        i += packet.buffer[i] + 1;
000BF2  E8801E     INC2 [W14], W0
000BF4  470000     ADD W14, W0, W0
000BF6  91D020     MOV.B [W0+210], W0
000BF8  FB8000     ZE W0, W0
000BFA  E80000     INC W0, W0
000BFC  400F1E     ADD W0, [W14], [W14]
77:                    }
78:                    pkg_send(send);
000C08  B00CCF     ADD #0xCC, W15
000C0A  2FF340     MOV #0xFF34, W0
000C0C  40000F     ADD W0, W15, W0
000C0E  78008E     MOV W14, W1
000C10  B00061     ADD #0x6, W1
000C12  090065     REPEAT #0x65
000C14  781831     MOV [W1++], [W0++]
000C16  B10CC0     SUB #0xCC, W0
000C18  0709E3     RCALL pkg_send
000C1A  B10CCF     SUB #0xCC, W15
79:                    return TMR1 - t; // Time of esecution
000C1C  800801     MOV TMR1, W1
000C1E  90002E     MOV [W14+4], W0
000C20  508000     SUB W1, W0, W0
80:                }
000C22  FA8000     ULNK
000C24  060000     RETURN
81:                
82:                information_packet_t decode_single_pkg(Ptr_packet send, char command, unsigned char* Buffer, unsigned int position) {
000C26  FA0274     LNK #0x274
000C28  781F88     MOV W8, [W15++]
000C2A  780400     MOV W0, W8
000C2C  999711     MOV W1, [W14+418]
000C2E  9B6742     MOV.B W2, [W14+420]
000C30  999733     MOV W3, [W14+422]
000C32  999744     MOV W4, [W14+424]
83:                    information_packet_t packet;
84:                    Ptr_abstract_packet ptr_packet_send;
85:                    abstract_packet_t packet_send;
86:                    services_t service;
87:                    unsigned char process_return;
88:                    switch (command) {
000C34  93604E     MOV.B [W14+420], W0
000C36  FB0000     SE W0, W0
000C38  B90161     MUL.SU W0, #1, W2
000C3A  2FFBF0     MOV #0xFFBF, W0
000C3C  2FFFF1     MOV #0xFFFF, W1
000C3E  400002     ADD W0, W2, W0
000C40  488083     ADDC W1, W3, W1
000C42  200332     MOV #0x33, W2
000C44  200003     MOV #0x0, W3
000C46  500F82     SUB W0, W2, [W15]
000C48  588F83     SUBB W1, W3, [W15]
000C4A  3E00FA     BRA GTU, 0xE40
000C4C  016000     BRA W0
000C4E  370043     BRA 0xCD6
000C50  370053     BRA 0xCF8
000C52  37006A     BRA 0xD28
000C54  3700F5     BRA 0xE40
000C56  3700A9     BRA 0xDAA
000C58  3700F3     BRA 0xE40
000C5A  3700F2     BRA 0xE40
000C5C  3700F1     BRA 0xE40
000C5E  3700F0     BRA 0xE40
000C60  3700EF     BRA 0xE40
000C62  3700EE     BRA 0xE40
000C64  3700ED     BRA 0xE40
000C66  370099     BRA 0xD9A
000C68  3700EB     BRA 0xE40
000C6A  3700EA     BRA 0xE40
000C6C  370073     BRA 0xD54
000C6E  3700E8     BRA 0xE40
000C70  3700E7     BRA 0xE40
000C72  3700E6     BRA 0xE40
000C74  370064     BRA 0xD3E
000C76  3700E4     BRA 0xE40
000C78  370085     BRA 0xD84
000C7A  3700E2     BRA 0xE40
000C7C  3700E1     BRA 0xE40
000C7E  3700E0     BRA 0xE40
000C80  3700DF     BRA 0xE40
000C82  3700DE     BRA 0xE40
000C84  3700DD     BRA 0xE40
000C86  3700DC     BRA 0xE40
000C88  3700DB     BRA 0xE40
000C8A  3700DA     BRA 0xE40
000C8C  3700D9     BRA 0xE40
000C8E  370013     BRA 0xCB6
000C90  37001A     BRA 0xCC6
000C92  3700D6     BRA 0xE40
000C94  3700D5     BRA 0xE40
000C96  3700D4     BRA 0xE40
000C98  3700A5     BRA 0xDE4
000C9A  3700D2     BRA 0xE40
000C9C  3700D1     BRA 0xE40
000C9E  3700D0     BRA 0xE40
000CA0  3700CF     BRA 0xE40
000CA2  3700CE     BRA 0xE40
000CA4  3700CD     BRA 0xE40
000CA6  3700CC     BRA 0xE40
000CA8  3700CB     BRA 0xE40
000CAA  3700CA     BRA 0xE40
000CAC  370091     BRA 0xDD0
000CAE  3700C8     BRA 0xE40
000CB0  3700C7     BRA 0xE40
000CB2  3700A2     BRA 0xDF8
000CB4  370085     BRA 0xDC0
89:                        case MOTOR_L:
90:                            // Impossible to change measure motor left
91:                            return addPacket(send, command, NACK, NULL);
000CB6  93604E     MOV.B [W14+420], W0
000CB8  EB0200     CLR W4
000CBA  B3C4E3     MOV #0x4E, W3
000CBC  784100     MOV.B W0, W2
000CBE  91909E     MOV [W14+418], W1
000CC0  780008     MOV W8, W0
000CC2  0700F0     RCALL addPacket
000CC4  3700C6     BRA 0xE52
92:                            break;
93:                        case MOTOR_R:
94:                            // Impossible to change measure motor left
95:                            return addPacket(send, command, NACK, NULL);
000CC6  93604E     MOV.B [W14+420], W0
000CC8  EB0200     CLR W4
000CCA  B3C4E3     MOV #0x4E, W3
000CCC  784100     MOV.B W0, W2
000CCE  91909E     MOV [W14+418], W1
000CD0  780008     MOV W8, W0
000CD2  0700E8     RCALL addPacket
000CD4  3700BE     BRA 0xE52
96:                            break;
97:                        case PID_CONTROL_L:
98:                            ptr_packet_send = (Ptr_abstract_packet) & pid_left;
000CD6  209360     MOV #0x936, W0
000CD8  780F00     MOV W0, [W14]
99:                            packet = addChangePacket(send, command, Buffer, position, LNG_PID_CONTROL, ptr_packet_send);
000CDA  470064     ADD W14, #0x4, W0
000CDC  78031E     MOV [W14], W6
000CDE  2000C5     MOV #0xC, W5
000CE0  91924E     MOV [W14+424], W4
000CE2  9191BE     MOV [W14+422], W3
000CE4  93614E     MOV.B [W14+420], W2
000CE6  91909E     MOV [W14+418], W1
000CE8  0700B8     RCALL addChangePacket
100:                           update_pid_l();
000CEA  070360     RCALL update_pid_l
101:                           return packet;
000CEC  78000E     MOV W14, W0
000CEE  B00040     ADD #0x4, W0
000CF0  090064     REPEAT #0x64
000CF2  781C30     MOV [W0++], [W8++]
000CF4  B10CA8     SUB #0xCA, W8
000CF6  3700AD     BRA 0xE52
102:                           break;
103:                       case PID_CONTROL_R:
104:                           ptr_packet_send = (Ptr_abstract_packet) & pid_right;
000CF8  209420     MOV #0x942, W0
000CFA  780F00     MOV W0, [W14]
105:                           packet = addChangePacket(send, command, Buffer, position, LNG_PID_CONTROL, ptr_packet_send);
000CFC  201AA0     MOV #0x1AA, W0
000CFE  40000E     ADD W0, W14, W0
000D00  78031E     MOV [W14], W6
000D02  2000C5     MOV #0xC, W5
000D04  91924E     MOV [W14+424], W4
000D06  9191BE     MOV [W14+422], W3
000D08  93614E     MOV.B [W14+420], W2
000D0A  91909E     MOV [W14+418], W1
000D0C  0700A6     RCALL addChangePacket
000D0E  78008E     MOV W14, W1
000D10  B00041     ADD #0x4, W1
000D12  78000E     MOV W14, W0
000D14  B01AA0     ADD #0x1AA, W0
000D16  090064     REPEAT #0x64
000D18  7818B0     MOV [W0++], [W1++]
106:                           update_pid_r();
000D1A  0703AE     RCALL update_pid_r
107:                           return packet;
000D1C  78008E     MOV W14, W1
000D1E  B00041     ADD #0x4, W1
000D20  090064     REPEAT #0x64
000D22  781C31     MOV [W1++], [W8++]
000D24  B10CA8     SUB #0xCA, W8
000D26  370095     BRA 0xE52
108:                           break;
109:                       case COORDINATE:
110:                           ptr_packet_send = (Ptr_abstract_packet) & coordinate;
000D28  209B80     MOV #0x9B8, W0
000D2A  780F00     MOV W0, [W14]
111:                           return addChangePacket(send, command, Buffer, position, LNG_COORDINATE, ptr_packet_send);
000D2C  78031E     MOV [W14], W6
000D2E  200105     MOV #0x10, W5
000D30  91924E     MOV [W14+424], W4
000D32  9191BE     MOV [W14+422], W3
000D34  93614E     MOV.B [W14+420], W2
000D36  91909E     MOV [W14+418], W1
000D38  780008     MOV W8, W0
000D3A  07008F     RCALL addChangePacket
000D3C  37008A     BRA 0xE52
112:                           break;
113:                       case CONSTRAINT:
114:                           ptr_packet_send = (Ptr_abstract_packet) & constraint;
000D3E  2091E0     MOV #0x91E, W0
000D40  780F00     MOV W0, [W14]
115:                           return addChangePacket(send, command, Buffer, position, LNG_CONSTRAINT, ptr_packet_send);
000D42  78031E     MOV [W14], W6
000D44  200085     MOV #0x8, W5
000D46  91924E     MOV [W14+424], W4
000D48  9191BE     MOV [W14+422], W3
000D4A  93614E     MOV.B [W14+420], W2
000D4C  91909E     MOV [W14+418], W1
000D4E  780008     MOV W8, W0
000D50  070084     RCALL addChangePacket
000D52  37007F     BRA 0xE52
116:                           break;
117:                       case PARAMETER:
118:                           ptr_packet_send = (Ptr_abstract_packet) & parameter;
000D54  208FA0     MOV #0x8FA, W0
000D56  780F00     MOV W0, [W14]
119:                           packet = addChangePacket(send, command, Buffer, position, LNG_PARAMETER, ptr_packet_send);
000D58  201AA0     MOV #0x1AA, W0
000D5A  40000E     ADD W0, W14, W0
000D5C  78031E     MOV [W14], W6
000D5E  200245     MOV #0x24, W5
000D60  91924E     MOV [W14+424], W4
000D62  9191BE     MOV [W14+422], W3
000D64  93614E     MOV.B [W14+420], W2
000D66  91909E     MOV [W14+418], W1
000D68  070078     RCALL addChangePacket
000D6A  78000E     MOV W14, W0
000D6C  B00040     ADD #0x4, W0
000D6E  78008E     MOV W14, W1
000D70  B01AA1     ADD #0x1AA, W1
000D72  090064     REPEAT #0x64
000D74  781831     MOV [W1++], [W0++]
120:                           update_parameter();
000D76  0702BA     RCALL update_parameter
121:                           return packet;
000D78  78000E     MOV W14, W0
000D7A  B00040     ADD #0x4, W0
000D7C  090064     REPEAT #0x64
000D7E  781C30     MOV [W0++], [W8++]
000D80  B10CA8     SUB #0xCA, W8
000D82  370067     BRA 0xE52
122:                           break;
123:                       case VELOCITY:
124:                           ptr_packet_send = (Ptr_abstract_packet) & vel_rif;
000D84  209260     MOV #0x926, W0
000D86  780F00     MOV W0, [W14]
125:                           return addChangePacket(send, command, Buffer, position, LNG_VELOCITY, ptr_packet_send);
000D88  78031E     MOV [W14], W6
000D8A  200085     MOV #0x8, W5
000D8C  91924E     MOV [W14+424], W4
000D8E  9191BE     MOV [W14+422], W3
000D90  93614E     MOV.B [W14+420], W2
000D92  91909E     MOV [W14+418], W1
000D94  780008     MOV W8, W0
000D96  070061     RCALL addChangePacket
000D98  37005C     BRA 0xE52
126:                           break;
127:                       case VELOCITY_MIS:
128:                           // Impossible to change velocity measure
129:                           return addPacket(send, command, NACK, NULL);
000D9A  93604E     MOV.B [W14+420], W0
000D9C  EB0200     CLR W4
000D9E  B3C4E3     MOV #0x4E, W3
000DA0  784100     MOV.B W0, W2
000DA2  91909E     MOV [W14+418], W1
000DA4  780008     MOV W8, W0
000DA6  07007E     RCALL addPacket
000DA8  370054     BRA 0xE52
130:                           break;
131:                       case ENABLE:
132:                           ptr_packet_send = (Ptr_abstract_packet) & enable_motors;
000DAA  2094E0     MOV #0x94E, W0
000DAC  780F00     MOV W0, [W14]
133:                           return addChangePacket(send, command, Buffer, position, LNG_ENABLE, ptr_packet_send);
000DAE  78031E     MOV [W14], W6
000DB0  200025     MOV #0x2, W5
000DB2  91924E     MOV [W14+424], W4
000DB4  9191BE     MOV [W14+422], W3
000DB6  93614E     MOV.B [W14+420], W2
000DB8  91909E     MOV [W14+418], W1
000DBA  780008     MOV W8, W0
000DBC  07004E     RCALL addChangePacket
000DBE  370049     BRA 0xE52
134:                           break;
135:                       case TIME_PROCESS:
136:                           return addPacket(send, command, NACK, NULL);
000DC0  93604E     MOV.B [W14+420], W0
000DC2  EB0200     CLR W4
000DC4  B3C4E3     MOV #0x4E, W3
000DC6  784100     MOV.B W0, W2
000DC8  91909E     MOV [W14+418], W1
000DCA  780008     MOV W8, W0
000DCC  07006B     RCALL addPacket
000DCE  370041     BRA 0xE52
137:                           break;
138:                       case PRIORITY_PROCESS:
139:                           process_return = update_priority();
000DD0  0705AF     RCALL update_priority
000DD2  984720     MOV.B W0, [W14+2]
140:                           return addPacket(send, command, process_return, NULL);
000DD4  93604E     MOV.B [W14+420], W0
000DD6  EB0200     CLR W4
000DD8  9041AE     MOV.B [W14+2], W3
000DDA  784100     MOV.B W0, W2
000DDC  91909E     MOV [W14+418], W1
000DDE  780008     MOV W8, W0
000DE0  070061     RCALL addPacket
000DE2  370037     BRA 0xE52
141:                           break;
142:                       case FRQ_PROCESS:
143:                           process_return = update_frequency();
000DE4  0705A9     RCALL update_frequency
000DE6  984720     MOV.B W0, [W14+2]
144:                           return addPacket(send, command, process_return, NULL);
000DE8  93604E     MOV.B [W14+420], W0
000DEA  EB0200     CLR W4
000DEC  9041AE     MOV.B [W14+2], W3
000DEE  784100     MOV.B W0, W2
000DF0  91909E     MOV [W14+418], W1
000DF2  780008     MOV W8, W0
000DF4  070057     RCALL addPacket
000DF6  37002D     BRA 0xE52
145:                           break;
146:                       case SERVICES:
147:                           //Save packet
148:                           ptr_packet_send = (Ptr_abstract_packet) & service;
000DF8  201961     MOV #0x196, W1
000DFA  470F01     ADD W14, W1, [W14]
149:                           addChangePacket(send, command, Buffer, position, LNG_SERVICES, ptr_packet_send);
000DFC  201AA0     MOV #0x1AA, W0
000DFE  40000E     ADD W0, W14, W0
000E00  78031E     MOV [W14], W6
000E02  2000B5     MOV #0xB, W5
000E04  91924E     MOV [W14+424], W4
000E06  9191BE     MOV [W14+422], W3
000E08  93614E     MOV.B [W14+420], W2
000E0A  91909E     MOV [W14+418], W1
000E0C  070026     RCALL addChangePacket
150:                           //Esecution service
151:                           packet_send.services = services(service);
000E0E  201AA0     MOV #0x1AA, W0
000E10  40000E     ADD W0, W14, W0
000E12  9188BE     MOV [W14+406], W1
000E14  91894E     MOV [W14+408], W2
000E16  9189DE     MOV [W14+410], W3
000E18  918A6E     MOV [W14+412], W4
000E1A  918AFE     MOV [W14+414], W5
000E1C  91930E     MOV [W14+416], W6
000E1E  070590     RCALL services
000E20  78000E     MOV W14, W0
000E22  B00CE0     ADD #0xCE, W0
000E24  78008E     MOV W14, W1
000E26  B01AA1     ADD #0x1AA, W1
000E28  09000A     REPEAT #0xA
000E2A  785831     MOV.B [W1++], [W0++]
152:                           //Send return service packet
153:                           return buildRequestPacket(send, command, LNG_SERVICES, &packet_send);
000E2C  93604E     MOV.B [W14+420], W0
000E2E  200CE1     MOV #0xCE, W1
000E30  40808E     ADD W1, W14, W1
000E32  780201     MOV W1, W4
000E34  2000B3     MOV #0xB, W3
000E36  784100     MOV.B W0, W2
000E38  91909E     MOV [W14+418], W1
000E3A  780008     MOV W8, W0
000E3C  0701BF     RCALL buildRequestPacket
000E3E  370009     BRA 0xE52
154:                           break;
155:                       default:
156:                           pkg_error(ERROR_PKG);
000E40  2FFF60     MOV #0xFFF6, W0
000E42  0708AD     RCALL pkg_error
157:                           return addPacket(send, command, NACK, NULL);
000E44  93604E     MOV.B [W14+420], W0
000E46  EB0200     CLR W4
000E48  B3C4E3     MOV #0x4E, W3
000E4A  784100     MOV.B W0, W2
000E4C  91909E     MOV [W14+418], W1
000E4E  780008     MOV W8, W0
000E50  070029     RCALL addPacket
158:                           break;
159:                   }
160:               }
000E52  780008     MOV W8, W0
000E54  78044F     MOV [--W15], W8
000E56  FA8000     ULNK
000E58  060000     RETURN
161:               
162:               information_packet_t addChangePacket(Ptr_packet send, char command, unsigned char* Buffer, unsigned int position, unsigned int length, Ptr_abstract_packet packet) {
000E5A  FA000C     LNK #0xC
000E5C  781F88     MOV W8, [W15++]
000E5E  780400     MOV W0, W8
000E60  780F01     MOV W1, [W14]
000E62  984722     MOV.B W2, [W14+2]
000E64  980723     MOV W3, [W14+4]
000E66  980734     MOV W4, [W14+6]
000E68  980745     MOV W5, [W14+8]
000E6A  980756     MOV W6, [W14+10]
163:                   if (packet != NULL) {
000E6C  90005E     MOV [W14+10], W0
000E6E  500FE0     SUB W0, #0x0, [W15]
000E70  32000E     BRA Z, 0xE8E
164:                       memcpy(packet->buffer, Buffer + (position * sizeof (unsigned char)), length);
000E72  9000AE     MOV [W14+4], W1
000E74  90003E     MOV [W14+6], W0
000E76  408080     ADD W1, W0, W1
000E78  90005E     MOV [W14+10], W0
000E7A  90014E     MOV [W14+8], W2
000E7C  07FE54     RCALL _memcpy
165:                       return addPacket(send, command, ACK, NULL);
000E7E  90402E     MOV.B [W14+2], W0
000E80  EB0200     CLR W4
000E82  B3C4B3     MOV #0x4B, W3
000E84  784100     MOV.B W0, W2
000E86  78009E     MOV [W14], W1
000E88  780008     MOV W8, W0
000E8A  07000C     RCALL addPacket
000E8C  370007     BRA 0xE9C
166:                   } else return addPacket(send, command, NACK, NULL);
000E8E  90402E     MOV.B [W14+2], W0
000E90  EB0200     CLR W4
000E92  B3C4E3     MOV #0x4E, W3
000E94  784100     MOV.B W0, W2
000E96  78009E     MOV [W14], W1
000E98  780008     MOV W8, W0
000E9A  070004     RCALL addPacket
167:               }
000E9C  780008     MOV W8, W0
000E9E  78044F     MOV [--W15], W8
000EA0  FA8000     ULNK
000EA2  060000     RETURN
168:               
169:               information_packet_t addPacket(Ptr_packet send, unsigned char command, unsigned char option, Ptr_abstract_packet packet) {
000EA4  FA0006     LNK #0x6
000EA6  781F88     MOV W8, [W15++]
000EA8  780400     MOV W0, W8
000EAA  780F01     MOV W1, [W14]
000EAC  984722     MOV.B W2, [W14+2]
000EAE  984733     MOV.B W3, [W14+3]
000EB0  980724     MOV W4, [W14+4]
170:                   switch (option) {
000EB2  90403E     MOV.B [W14+3], W0
000EB4  FB8000     ZE W0, W0
000EB6  B90161     MUL.SU W0, #1, W2
000EB8  2FFBD0     MOV #0xFFBD, W0
000EBA  2FFFF1     MOV #0xFFFF, W1
000EBC  400002     ADD W0, W2, W0
000EBE  488083     ADDC W1, W3, W1
000EC0  2000F2     MOV #0xF, W2
000EC2  200003     MOV #0x0, W3
000EC4  500F82     SUB W0, W2, [W15]
000EC6  588F83     SUBB W1, W3, [W15]
000EC8  3E001D     BRA GTU, 0xF04
000ECA  016000     BRA W0
000ECC  37000F     BRA 0xEEC
000ECE  37001A     BRA 0xF04
000ED0  370019     BRA 0xF04
000ED2  370018     BRA 0xF04
000ED4  370017     BRA 0xF04
000ED6  370016     BRA 0xF04
000ED8  370015     BRA 0xF04
000EDA  370014     BRA 0xF04
000EDC  37000D     BRA 0xEF8
000EDE  370012     BRA 0xF04
000EE0  370011     BRA 0xF04
000EE2  37000A     BRA 0xEF8
000EE4  37000F     BRA 0xF04
000EE6  37000E     BRA 0xF04
000EE8  37000D     BRA 0xF04
000EEA  370000     BRA 0xEEC
171:                       case REQUEST:
172:                       case CHANGE:
173:                           return addRequestPacket(send, command, packet);
000EEC  9001AE     MOV [W14+4], W3
000EEE  90412E     MOV.B [W14+2], W2
000EF0  78009E     MOV [W14], W1
000EF2  780008     MOV W8, W0
000EF4  070013     RCALL addRequestPacket
000EF6  37000E     BRA 0xF14
174:                           break;
175:                       case ACK:
176:                       case NACK:
177:                           return addInformationPacket(send, command, option);
000EF8  9041BE     MOV.B [W14+3], W3
000EFA  90412E     MOV.B [W14+2], W2
000EFC  78009E     MOV [W14], W1
000EFE  780008     MOV W8, W0
000F00  070136     RCALL addInformationPacket
000F02  370008     BRA 0xF14
178:                           break;
179:                       default:
180:                           pkg_error(ERROR_OPTION);
000F04  2FFF70     MOV #0xFFF7, W0
000F06  07084B     RCALL pkg_error
181:                           return addPacket(send, command, NACK, NULL);
000F08  EB0200     CLR W4
000F0A  B3C4E3     MOV #0x4E, W3
000F0C  90412E     MOV.B [W14+2], W2
000F0E  78009E     MOV [W14], W1
000F10  780008     MOV W8, W0
000F12  07FFC8     RCALL addPacket
182:                           break;
183:                   }
184:               }
000F14  780008     MOV W8, W0
000F16  78044F     MOV [--W15], W8
000F18  FA8000     ULNK
000F1A  060000     RETURN
185:               
186:               information_packet_t addRequestPacket(Ptr_packet send, unsigned char command, Ptr_abstract_packet pkg) {
000F1C  FA00CE     LNK #0xCE
000F1E  781F88     MOV W8, [W15++]
000F20  780400     MOV W0, W8
000F22  98A741     MOV W1, [W14+200]
000F24  99CF22     MOV.B W2, [W14+202]
000F26  98A763     MOV W3, [W14+204]
187:                   abstract_packet_t packet;
188:                   switch (command) {
000F28  91C82E     MOV.B [W14+202], W0
000F2A  FB8000     ZE W0, W0
000F2C  B90161     MUL.SU W0, #1, W2
000F2E  2FFBF0     MOV #0xFFBF, W0
000F30  2FFFF1     MOV #0xFFFF, W1
000F32  400002     ADD W0, W2, W0
000F34  488083     ADDC W1, W3, W1
000F36  200332     MOV #0x33, W2
000F38  200003     MOV #0x0, W3
000F3A  500F82     SUB W0, W2, [W15]
000F3C  588F83     SUBB W1, W3, [W15]
000F3E  3E010B     BRA GTU, 0x1156
000F40  016000     BRA W0
000F42  37004B     BRA 0xFDA
000F44  37005F     BRA 0x1004
000F46  370073     BRA 0x102E
000F48  370106     BRA 0x1156
000F4A  3700AB     BRA 0x10A2
000F4C  370104     BRA 0x1156
000F4E  370103     BRA 0x1156
000F50  370102     BRA 0x1156
000F52  370101     BRA 0x1156
000F54  370100     BRA 0x1156
000F56  3700FF     BRA 0x1156
000F58  3700FE     BRA 0x1156
000F5A  370097     BRA 0x108A
000F5C  3700FC     BRA 0x1156
000F5E  3700FB     BRA 0x1156
000F60  370071     BRA 0x1044
000F62  3700F9     BRA 0x1156
000F64  3700F8     BRA 0x1156
000F66  3700F7     BRA 0x1156
000F68  370078     BRA 0x105A
000F6A  3700F5     BRA 0x1156
000F6C  370082     BRA 0x1072
000F6E  3700F3     BRA 0x1156
000F70  3700F2     BRA 0x1156
000F72  3700F1     BRA 0x1156
000F74  3700F0     BRA 0x1156
000F76  3700EF     BRA 0x1156
000F78  3700EE     BRA 0x1156
000F7A  3700ED     BRA 0x1156
000F7C  3700EC     BRA 0x1156
000F7E  3700EB     BRA 0x1156
000F80  3700EA     BRA 0x1156
000F82  370013     BRA 0xFAA
000F84  37001E     BRA 0xFC2
000F86  3700E7     BRA 0x1156
000F88  3700E6     BRA 0x1156
000F8A  3700E5     BRA 0x1156
000F8C  3700C8     BRA 0x111E
000F8E  3700E3     BRA 0x1156
000F90  3700E2     BRA 0x1156
000F92  3700E1     BRA 0x1156
000F94  3700E0     BRA 0x1156
000F96  3700DF     BRA 0x1156
000F98  3700DE     BRA 0x1156
000F9A  3700DD     BRA 0x1156
000F9C  3700DC     BRA 0x1156
000F9E  3700DB     BRA 0x1156
000FA0  3700A9     BRA 0x10F4
000FA2  3700D9     BRA 0x1156
000FA4  3700D8     BRA 0x1156
000FA6  3700D0     BRA 0x1148
000FA8  370090     BRA 0x10CA
189:                       case MOTOR_L:
190:                           packet.motor = motor_left;
000FAA  209500     MOV #0x950, W0
000FAC  BE0230     MOV.D [W0++], W4
000FAE  BE0320     MOV.D [W0--], W6
000FB0  BE9F04     MOV.D W4, [W14++]
000FB2  BE9706     MOV.D W6, [W14--]
191:                           return buildRequestPacket(send, command, LNG_MOTOR, &packet);
000FB4  78020E     MOV W14, W4
000FB6  200083     MOV #0x8, W3
000FB8  91C92E     MOV.B [W14+202], W2
000FBA  90A0CE     MOV [W14+200], W1
000FBC  780008     MOV W8, W0
000FBE  0700FE     RCALL buildRequestPacket
000FC0  3700D2     BRA 0x1166
192:                           break;
193:                       case MOTOR_R:
194:                           packet.motor = motor_right;
000FC2  209580     MOV #0x958, W0
000FC4  BE0230     MOV.D [W0++], W4
000FC6  BE0320     MOV.D [W0--], W6
000FC8  BE9F04     MOV.D W4, [W14++]
000FCA  BE9706     MOV.D W6, [W14--]
195:                           return buildRequestPacket(send, command, LNG_MOTOR, &packet);
000FCC  78020E     MOV W14, W4
000FCE  200083     MOV #0x8, W3
000FD0  91C92E     MOV.B [W14+202], W2
000FD2  90A0CE     MOV [W14+200], W1
000FD4  780008     MOV W8, W0
000FD6  0700F2     RCALL buildRequestPacket
000FD8  3700C6     BRA 0x1166
196:                           break;
197:                       case PID_CONTROL_L:
198:                           packet.pid = pid_left;
000FDA  209360     MOV #0x936, W0
000FDC  78008E     MOV W14, W1
000FDE  BE0310     MOV.D [W0], W6
000FE0  BE8886     MOV.D W6, [W1]
000FE2  4080E4     ADD W1, #0x4, W1
000FE4  400064     ADD W0, #0x4, W0
000FE6  BE0110     MOV.D [W0], W2
000FE8  BE8882     MOV.D W2, [W1]
000FEA  4080E4     ADD W1, #0x4, W1
000FEC  400064     ADD W0, #0x4, W0
000FEE  BE0210     MOV.D [W0], W4
000FF0  BE8884     MOV.D W4, [W1]
000FF2  4080E4     ADD W1, #0x4, W1
000FF4  400064     ADD W0, #0x4, W0
199:                           return buildRequestPacket(send, command, LNG_PID_CONTROL, &packet);
000FF6  78020E     MOV W14, W4
000FF8  2000C3     MOV #0xC, W3
000FFA  91C92E     MOV.B [W14+202], W2
000FFC  90A0CE     MOV [W14+200], W1
000FFE  780008     MOV W8, W0
001000  0700DD     RCALL buildRequestPacket
001002  3700B1     BRA 0x1166
200:                           break;
201:                       case PID_CONTROL_R:
202:                           packet.pid = pid_right;
001004  209420     MOV #0x942, W0
001006  78008E     MOV W14, W1
001008  BE0310     MOV.D [W0], W6
00100A  BE8886     MOV.D W6, [W1]
00100C  4080E4     ADD W1, #0x4, W1
00100E  400064     ADD W0, #0x4, W0
001010  BE0110     MOV.D [W0], W2
001012  BE8882     MOV.D W2, [W1]
001014  4080E4     ADD W1, #0x4, W1
001016  400064     ADD W0, #0x4, W0
001018  BE0210     MOV.D [W0], W4
00101A  BE8884     MOV.D W4, [W1]
00101C  4080E4     ADD W1, #0x4, W1
00101E  400064     ADD W0, #0x4, W0
203:                           return buildRequestPacket(send, command, LNG_PID_CONTROL, &packet);
001020  78020E     MOV W14, W4
001022  2000C3     MOV #0xC, W3
001024  91C92E     MOV.B [W14+202], W2
001026  90A0CE     MOV [W14+200], W1
001028  780008     MOV W8, W0
00102A  0700C8     RCALL buildRequestPacket
00102C  37009C     BRA 0x1166
204:                           break;
205:                       case COORDINATE:
206:                           packet.coordinate = coordinate;
00102E  209B85     MOV #0x9B8, W5
001030  090007     REPEAT #0x7
001032  781F35     MOV [W5++], [W14++]
001034  B1010E     SUB #0x10, W14
207:                           //            protectedMemcpy(DEAD_RECK_ENABLE, &packet.coordinate, &coordinate, sizeof (coordinate));
208:                           return buildRequestPacket(send, command, LNG_COORDINATE, &packet);
001036  78020E     MOV W14, W4
001038  200103     MOV #0x10, W3
00103A  91C92E     MOV.B [W14+202], W2
00103C  90A0CE     MOV [W14+200], W1
00103E  780008     MOV W8, W0
001040  0700BD     RCALL buildRequestPacket
001042  370091     BRA 0x1166
209:                           break;
210:                       case PARAMETER:
211:                           packet.parameter = parameter;
001044  208FA6     MOV #0x8FA, W6
001046  090011     REPEAT #0x11
001048  781F36     MOV [W6++], [W14++]
00104A  B1024E     SUB #0x24, W14
212:                           return buildRequestPacket(send, command, LNG_PARAMETER, &packet);
00104C  78020E     MOV W14, W4
00104E  200243     MOV #0x24, W3
001050  91C92E     MOV.B [W14+202], W2
001052  90A0CE     MOV [W14+200], W1
001054  780008     MOV W8, W0
001056  0700B2     RCALL buildRequestPacket
001058  370086     BRA 0x1166
213:                           break;
214:                       case CONSTRAINT:
215:                           packet.constraint = constraint;
00105A  2091E0     MOV #0x91E, W0
00105C  BE0230     MOV.D [W0++], W4
00105E  BE0320     MOV.D [W0--], W6
001060  BE9F04     MOV.D W4, [W14++]
001062  BE9706     MOV.D W6, [W14--]
216:                           return buildRequestPacket(send, command, LNG_CONSTRAINT, &packet);
001064  78020E     MOV W14, W4
001066  200083     MOV #0x8, W3
001068  91C92E     MOV.B [W14+202], W2
00106A  90A0CE     MOV [W14+200], W1
00106C  780008     MOV W8, W0
00106E  0700A6     RCALL buildRequestPacket
001070  37007A     BRA 0x1166
217:                           break;
218:                       case VELOCITY:
219:                           packet.velocity = vel_rif;
001072  209260     MOV #0x926, W0
001074  BE0230     MOV.D [W0++], W4
001076  BE0320     MOV.D [W0--], W6
001078  BE9F04     MOV.D W4, [W14++]
00107A  BE9706     MOV.D W6, [W14--]
220:                           return buildRequestPacket(send, command, LNG_VELOCITY, &packet);
00107C  78020E     MOV W14, W4
00107E  200083     MOV #0x8, W3
001080  91C92E     MOV.B [W14+202], W2
001082  90A0CE     MOV [W14+200], W1
001084  780008     MOV W8, W0
001086  07009A     RCALL buildRequestPacket
001088  37006E     BRA 0x1166
221:                           break;
222:                       case VELOCITY_MIS:
223:                           //            memcpy(&packet.velocity, &vel_mis, sizeof (velocity_t));
224:                           packet.velocity = vel_mis;
00108A  2092E0     MOV #0x92E, W0
00108C  BE0230     MOV.D [W0++], W4
00108E  BE0320     MOV.D [W0--], W6
001090  BE9F04     MOV.D W4, [W14++]
001092  BE9706     MOV.D W6, [W14--]
225:                           return buildRequestPacket(send, command, LNG_VELOCITY, &packet);
001094  78020E     MOV W14, W4
001096  200083     MOV #0x8, W3
001098  91C92E     MOV.B [W14+202], W2
00109A  90A0CE     MOV [W14+200], W1
00109C  780008     MOV W8, W0
00109E  07008E     RCALL buildRequestPacket
0010A0  370062     BRA 0x1166
226:                           break;
227:                       case ENABLE:
228:                           packet.enable = MOTOR_ENABLE1 && MOTOR_ENABLE2;
0010A2  801660     MOV LATB, W0
0010A4  600064     AND W0, #0x4, W0
0010A6  500FE0     SUB W0, #0x0, [W15]
0010A8  320006     BRA Z, 0x10B6
0010AA  801660     MOV LATB, W0
0010AC  600068     AND W0, #0x8, W0
0010AE  500FE0     SUB W0, #0x0, [W15]
0010B0  320002     BRA Z, 0x10B6
0010B2  200010     MOV #0x1, W0
0010B4  370001     BRA 0x10B8
0010B6  EB0000     CLR W0
0010B8  784000     MOV.B W0, W0
0010BA  784F00     MOV.B W0, [W14]
229:                           return buildRequestPacket(send, command, LNG_ENABLE, &packet);
0010BC  78020E     MOV W14, W4
0010BE  200023     MOV #0x2, W3
0010C0  91C92E     MOV.B [W14+202], W2
0010C2  90A0CE     MOV [W14+200], W1
0010C4  780008     MOV W8, W0
0010C6  07007A     RCALL buildRequestPacket
0010C8  37004E     BRA 0x1166
230:                           break;
231:                       case TIME_PROCESS:
232:                           packet.process = time;
0010CA  247D40     MOV #0x47D4, W0
0010CC  78008E     MOV W14, W1
0010CE  BE0310     MOV.D [W0], W6
0010D0  BE8886     MOV.D W6, [W1]
0010D2  4080E4     ADD W1, #0x4, W1
0010D4  400064     ADD W0, #0x4, W0
0010D6  BE0110     MOV.D [W0], W2
0010D8  BE8882     MOV.D W2, [W1]
0010DA  4080E4     ADD W1, #0x4, W1
0010DC  400064     ADD W0, #0x4, W0
0010DE  BE0210     MOV.D [W0], W4
0010E0  BE8884     MOV.D W4, [W1]
0010E2  4080E4     ADD W1, #0x4, W1
0010E4  400064     ADD W0, #0x4, W0
233:                           return buildRequestPacket(send, command, LNG_PROCESS, &packet);
0010E6  78020E     MOV W14, W4
0010E8  2000C3     MOV #0xC, W3
0010EA  91C92E     MOV.B [W14+202], W2
0010EC  90A0CE     MOV [W14+200], W1
0010EE  780008     MOV W8, W0
0010F0  070065     RCALL buildRequestPacket
0010F2  370039     BRA 0x1166
234:                           break;
235:                       case PRIORITY_PROCESS:
236:                           packet.process = priority;
0010F4  247E00     MOV #0x47E0, W0
0010F6  78008E     MOV W14, W1
0010F8  BE0310     MOV.D [W0], W6
0010FA  BE8886     MOV.D W6, [W1]
0010FC  4080E4     ADD W1, #0x4, W1
0010FE  400064     ADD W0, #0x4, W0
001100  BE0110     MOV.D [W0], W2
001102  BE8882     MOV.D W2, [W1]
001104  4080E4     ADD W1, #0x4, W1
001106  400064     ADD W0, #0x4, W0
001108  BE0210     MOV.D [W0], W4
00110A  BE8884     MOV.D W4, [W1]
00110C  4080E4     ADD W1, #0x4, W1
00110E  400064     ADD W0, #0x4, W0
237:                           return buildRequestPacket(send, command, LNG_PROCESS, &packet);
001110  78020E     MOV W14, W4
001112  2000C3     MOV #0xC, W3
001114  91C92E     MOV.B [W14+202], W2
001116  90A0CE     MOV [W14+200], W1
001118  780008     MOV W8, W0
00111A  070050     RCALL buildRequestPacket
00111C  370024     BRA 0x1166
238:                           break;
239:                       case FRQ_PROCESS:
240:                           packet.process = frequency;
00111E  247EC0     MOV #0x47EC, W0
001120  78008E     MOV W14, W1
001122  BE0310     MOV.D [W0], W6
001124  BE8886     MOV.D W6, [W1]
001126  4080E4     ADD W1, #0x4, W1
001128  400064     ADD W0, #0x4, W0
00112A  BE0110     MOV.D [W0], W2
00112C  BE8882     MOV.D W2, [W1]
00112E  4080E4     ADD W1, #0x4, W1
001130  400064     ADD W0, #0x4, W0
001132  BE0210     MOV.D [W0], W4
001134  BE8884     MOV.D W4, [W1]
001136  4080E4     ADD W1, #0x4, W1
001138  400064     ADD W0, #0x4, W0
241:                           return buildRequestPacket(send, command, LNG_PROCESS, &packet);
00113A  78020E     MOV W14, W4
00113C  2000C3     MOV #0xC, W3
00113E  91C92E     MOV.B [W14+202], W2
001140  90A0CE     MOV [W14+200], W1
001142  780008     MOV W8, W0
001144  07003B     RCALL buildRequestPacket
001146  37000F     BRA 0x1166
242:                           break;
243:                       case SERVICES:
244:                           //TODO
245:                           return addPacket(send, command, NACK, NULL);
001148  EB0200     CLR W4
00114A  B3C4E3     MOV #0x4E, W3
00114C  91C92E     MOV.B [W14+202], W2
00114E  90A0CE     MOV [W14+200], W1
001150  780008     MOV W8, W0
001152  07FEA8     RCALL addPacket
001154  370008     BRA 0x1166
246:                           break;
247:                       default:
248:                           pkg_error(ERROR_CREATE_PKG);
001156  2FFF50     MOV #0xFFF5, W0
001158  070722     RCALL pkg_error
249:                           return addPacket(send, command, NACK, NULL);
00115A  EB0200     CLR W4
00115C  B3C4E3     MOV #0x4E, W3
00115E  91C92E     MOV.B [W14+202], W2
001160  90A0CE     MOV [W14+200], W1
001162  780008     MOV W8, W0
001164  07FE9F     RCALL addPacket
250:                           break;
251:                   }
252:               }
001166  780008     MOV W8, W0
001168  78044F     MOV [--W15], W8
00116A  FA8000     ULNK
00116C  060000     RETURN
253:               
254:               information_packet_t addInformationPacket(Ptr_packet send, unsigned char command, unsigned char option) {
00116E  FA00CE     LNK #0xCE
001170  98A751     MOV W1, [W14+202]
001172  99CF42     MOV.B W2, [W14+204]
001174  99CF53     MOV.B W3, [W14+205]
255:                   send->buffer[send->length] = 1;
001176  90A0DE     MOV [W14+202], W1
001178  780091     MOV [W1], W1
00117A  90A15E     MOV [W14+202], W2
00117C  410101     ADD W2, W1, W2
00117E  B3C011     MOV #0x1, W1
001180  984121     MOV.B W1, [W2+2]
256:                   send->buffer[send->length + 1] = command;
001182  90A0DE     MOV [W14+202], W1
001184  780091     MOV [W1], W1
001186  E80081     INC W1, W1
001188  90A15E     MOV [W14+202], W2
00118A  410081     ADD W2, W1, W1
00118C  91C94E     MOV.B [W14+204], W2
00118E  9840A2     MOV.B W2, [W1+2]
257:                   send->buffer[send->length + 2] = option;
001190  90A0DE     MOV [W14+202], W1
001192  780091     MOV [W1], W1
001194  E88081     INC2 W1, W1
001196  90A15E     MOV [W14+202], W2
001198  410081     ADD W2, W1, W1
00119A  91C95E     MOV.B [W14+205], W2
00119C  9840A2     MOV.B W2, [W1+2]
258:                   send->length += 3;
00119E  90A0DE     MOV [W14+202], W1
0011A0  780091     MOV [W1], W1
0011A2  408163     ADD W1, #0x3, W2
0011A4  90A0DE     MOV [W14+202], W1
0011A6  780882     MOV W2, [W1]
259:                   information_packet_t option_pkg;
260:                   option_pkg.command = command;
0011A8  91C8CE     MOV.B [W14+204], W1
0011AA  784F01     MOV.B W1, [W14]
261:                   option_pkg.option = option;
0011AC  91C95E     MOV.B [W14+205], W2
0011AE  984712     MOV.B W2, [W14+1]
262:                   return option_pkg;
0011B0  090064     REPEAT #0x64
0011B2  78183E     MOV [W14++], [W0++]
0011B4  B10CA0     SUB #0xCA, W0
0011B6  B10CAE     SUB #0xCA, W14
263:               }
0011B8  FA8000     ULNK
0011BA  060000     RETURN
264:               
265:               information_packet_t buildRequestPacket(Ptr_packet send, unsigned char command, const unsigned int length, Ptr_abstract_packet packet) {
0011BC  FA00D2     LNK #0xD2
0011BE  781F88     MOV W8, [W15++]
0011C0  780400     MOV W0, W8
0011C2  98A751     MOV W1, [W14+202]
0011C4  99CF42     MOV.B W2, [W14+204]
0011C6  98A773     MOV W3, [W14+206]
0011C8  98AF04     MOV W4, [W14+208]
266:                   if (packet != NULL) {
0011CA  90A80E     MOV [W14+208], W0
0011CC  500FE0     SUB W0, #0x0, [W15]
0011CE  32002B     BRA Z, 0x1226
267:                       information_packet_t request_packet;
268:                       send->buffer[send->length] = length;
0011D0  90A05E     MOV [W14+202], W0
0011D2  780090     MOV [W0], W1
0011D4  90A07E     MOV [W14+206], W0
0011D6  784000     MOV.B W0, W0
0011D8  90A15E     MOV [W14+202], W2
0011DA  410081     ADD W2, W1, W1
0011DC  9840A0     MOV.B W0, [W1+2]
269:                       send->buffer[send->length + 1] = command;
0011DE  90A05E     MOV [W14+202], W0
0011E0  780010     MOV [W0], W0
0011E2  E80000     INC W0, W0
0011E4  90A0DE     MOV [W14+202], W1
0011E6  408000     ADD W1, W0, W0
0011E8  91C8CE     MOV.B [W14+204], W1
0011EA  984021     MOV.B W1, [W0+2]
270:                       memcpy(send->buffer + (send->length + 2) * sizeof (unsigned char), packet->buffer, length);
0011EC  90A88E     MOV [W14+208], W1
0011EE  90A05E     MOV [W14+202], W0
0011F0  E88100     INC2 W0, W2
0011F2  90A05E     MOV [W14+202], W0
0011F4  780010     MOV [W0], W0
0011F6  E88000     INC2 W0, W0
0011F8  410000     ADD W2, W0, W0
0011FA  90A17E     MOV [W14+206], W2
0011FC  07FC94     RCALL _memcpy
271:                       send->length += length + 2;
0011FE  90A05E     MOV [W14+202], W0
001200  780090     MOV [W0], W1
001202  90A07E     MOV [W14+206], W0
001204  408000     ADD W1, W0, W0
001206  E88080     INC2 W0, W1
001208  90A05E     MOV [W14+202], W0
00120A  780801     MOV W1, [W0]
272:                       request_packet.command = command;
00120C  91C84E     MOV.B [W14+204], W0
00120E  784F00     MOV.B W0, [W14]
273:                       request_packet.option = REQUEST;
001210  B3C520     MOV #0x52, W0
001212  984710     MOV.B W0, [W14+1]
274:                       memcpy(&request_packet.packet.buffer, packet->buffer, length);
001214  90A88E     MOV [W14+208], W1
001216  E8800E     INC2 W14, W0
001218  90A17E     MOV [W14+206], W2
00121A  07FC85     RCALL _memcpy
275:                       return request_packet;
00121C  090064     REPEAT #0x64
00121E  781C3E     MOV [W14++], [W8++]
001220  B10CA8     SUB #0xCA, W8
001222  B10CAE     SUB #0xCA, W14
001224  370005     BRA 0x1230
276:                   } else {
277:                       return addInformationPacket(send, command, REQUEST);
001226  B3C523     MOV #0x52, W3
001228  91C94E     MOV.B [W14+204], W2
00122A  90A0DE     MOV [W14+202], W1
00122C  780008     MOV W8, W0
00122E  07FF9F     RCALL addInformationPacket
278:                   }
279:               }
001230  780008     MOV W8, W0
001232  78044F     MOV [--W15], W8
001234  FA8000     ULNK
001236  060000     RETURN
---  C:/Users/Raffaello/Dropbox/MicrochipProject/dsPIC33MotionControl.X/motors_PID.c  -------------------
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                #include <stdint.h>          /* For uint16_t definition                       */
17:                #include <stdbool.h>         /* For true/false definition                     */
18:                #include <dsp.h>
19:                #include <pwm12.h>
20:                #include "motors_PID.h"       /* variables/params used by motorsPID.c         */
21:                #include "system.h"
22:                #include "user.h"
23:                #include "packet.h"
24:                
25:                /******************************************************************************/
26:                /* Global Variable Declaration                                                */
27:                /******************************************************************************/
28:                
29:                tPID PIDstruct1; // PID motore Sinistra
30:                fractional abcCoefficient1[3] __attribute__((section(".xbss, bss, xmemory")));
31:                fractional controlHistory1[3] __attribute__((section(".ybss, bss, ymemory")));
32:                fractional kCoeffs1[3]; //Coefficienti KP, KI, KD Per PID1 Sinistra
33:                tPID PIDstruct2; //PID motore Destra
34:                fractional abcCoefficient2[3] __attribute__((section(".xbss, bss, xmemory")));
35:                fractional controlHistory2[3] __attribute__((section(".ybss, bss, ymemory")));
36:                fractional kCoeffs2[3]; //Coefficienti KP, KI, KD Per PID2 Destra
37:                
38:                // ADC buffer, 2 channels (AN0, AN1), 32 bytes each, 2 x 32 = 64 bytes
39:                int AdcBuffer[2][ADC_BUFF] __attribute__((space(dma), aligned(256)));
40:                
41:                /** */
42:                
43:                volatile int PulsEncL = 0; //Buffer for deadReckoning
44:                volatile int PulsEncR = 0; //Buffer for deadReckoning
45:                
46:                //volatile parameter_t parameter;
47:                //volatile velocity_t vel_rif, vel_mis;
48:                //volatile pid_control_t pid_left, pid_right;
49:                //volatile enable_motor_t enable_motors;
50:                
51:                parameter_t parameter;
52:                constraint_t constraint;
53:                velocity_t vel_rif, vel_mis;
54:                pid_control_t pid_left, pid_right;
55:                enable_motor_t enable_motors;
56:                motor_t motor_left, motor_right;
57:                
58:                float const_vel[3];
59:                
60:                typedef struct parameter_int {
61:                    long radius_l;
62:                    long radius_r;
63:                    long wheelbase;
64:                    long k_vel_l;
65:                    long k_vel_r;
66:                } parameter_int_t;
67:                
68:                k_odo_t k_odo;
69:                float wheel_m;
70:                
71:                parameter_int_t parameter_int;
72:                
73:                /**/
74:                
75:                extern volatile unsigned long timePeriodL; //Periodo Ruota Sinistra
76:                extern volatile unsigned long timePeriodR; //Periodo Ruota Destra
77:                extern volatile unsigned SIG_VELL; //Verso rotazione ruota Sinistra
78:                extern volatile unsigned SIG_VELR; //Verso rotazione ruota Destra
79:                
80:                /******************************************************************************/
81:                /* User Functions                                                             */
82:                
83:                /******************************************************************************/
84:                
85:                void init_parameter(void) {
001238  FA0000     LNK #0x0
86:                    parameter.radius_l = 0.04; //Raggio ruota sinistra
00123A  2D70A0     MOV #0xD70A, W0
00123C  23D231     MOV #0x3D23, W1
00123E  8847F0     MOV W0, 0x8FE
001240  884801     MOV W1, 0x900
87:                    parameter.radius_r = 0.04; //Raggio ruota destra
001242  2D70A0     MOV #0xD70A, W0
001244  23D231     MOV #0x3D23, W1
001246  8847D0     MOV W0, parameter
001248  8847E1     MOV W1, 0x8FC
88:                    parameter.wheelbase = 0.20; //Interasse
00124A  2CCCD0     MOV #0xCCCD, W0
00124C  23E4C1     MOV #0x3E4C, W1
00124E  884810     MOV W0, 0x902
001250  884821     MOV W1, 0x904
89:                    parameter.k_vel_l = K_VEL; //Costante velocit
001252  20D8A0     MOV #0xD8A, W0
001254  24BD51     MOV #0x4BD5, W1
001256  884850     MOV W0, 0x90A
001258  884861     MOV W1, 0x90C
90:                    parameter.k_vel_r = K_VEL;
00125A  20D8A0     MOV #0xD8A, W0
00125C  24BD51     MOV #0x4BD5, W1
00125E  884830     MOV W0, 0x906
001260  884841     MOV W1, 0x908
91:                    parameter.k_ang_l = K_ANG; //Constante angolare
001262  202D30     MOV #0x2D3, W0
001264  239371     MOV #0x3937, W1
001266  884890     MOV W0, 0x912
001268  8848A1     MOV W1, 0x914
92:                    parameter.k_ang_r = K_ANG;
00126A  202D30     MOV #0x2D3, W0
00126C  239371     MOV #0x3937, W1
00126E  884870     MOV W0, 0x90E
001270  884881     MOV W1, 0x910
93:                    parameter.sp_min = 0.0001; // FLT_MIN
001272  2B7170     MOV #0xB717, W0
001274  238D11     MOV #0x38D1, W1
001276  8848B0     MOV W0, 0x916
001278  8848C1     MOV W1, 0x918
94:                
95:                    update_parameter();
00127A  070038     RCALL update_parameter
96:                
97:                    vel_rif.v = 0;
00127C  209262     MOV #0x926, W2
00127E  B80060     MUL.UU W0, #0, W0
001280  BE8900     MOV.D W0, [W2]
98:                    vel_rif.w = 0;
001282  209262     MOV #0x926, W2
001284  B80060     MUL.UU W0, #0, W0
001286  980120     MOV W0, [W2+4]
001288  980131     MOV W1, [W2+6]
99:                    vel_mis.v = 0;
00128A  2092E2     MOV #0x92E, W2
00128C  B80060     MUL.UU W0, #0, W0
00128E  BE8900     MOV.D W0, [W2]
100:                   vel_mis.w = 0;
001290  2092E2     MOV #0x92E, W2
001292  B80060     MUL.UU W0, #0, W0
001294  980120     MOV W0, [W2+4]
001296  980131     MOV W1, [W2+6]
101:                   motor_left.control_vel = 0;
001298  209500     MOV #0x950, W0
00129A  EB0080     CLR W1
00129C  980011     MOV W1, [W0+2]
102:                   motor_left.measure_vel = 0;
00129E  209500     MOV #0x950, W0
0012A0  EB0080     CLR W1
0012A2  980021     MOV W1, [W0+4]
103:                   motor_left.rifer_vel = 0;
0012A4  209500     MOV #0x950, W0
0012A6  EB0080     CLR W1
0012A8  780801     MOV W1, [W0]
104:                   motor_left.current = 0;
0012AA  209500     MOV #0x950, W0
0012AC  EB0080     CLR W1
0012AE  980031     MOV W1, [W0+6]
105:                   motor_right.control_vel = 0;
0012B0  209580     MOV #0x958, W0
0012B2  EB0080     CLR W1
0012B4  980011     MOV W1, [W0+2]
106:                   motor_right.measure_vel = 0;
0012B6  209580     MOV #0x958, W0
0012B8  EB0080     CLR W1
0012BA  980021     MOV W1, [W0+4]
107:                   motor_right.rifer_vel = 0;
0012BC  209580     MOV #0x958, W0
0012BE  EB0080     CLR W1
0012C0  780801     MOV W1, [W0]
108:                   motor_right.current = 0;
0012C2  209580     MOV #0x958, W0
0012C4  EB0080     CLR W1
0012C6  980031     MOV W1, [W0+6]
109:               
110:                   constraint.max_left = 14000;
0012C8  2091E2     MOV #0x91E, W2
0012CA  2C0000     MOV #0xC000, W0
0012CC  2465A1     MOV #0x465A, W1
0012CE  BE8900     MOV.D W0, [W2]
111:                   constraint.max_right = 14000;
0012D0  2091E2     MOV #0x91E, W2
0012D2  2C0000     MOV #0xC000, W0
0012D4  2465A1     MOV #0x465A, W1
0012D6  980120     MOV W0, [W2+4]
0012D8  980131     MOV W1, [W2+6]
112:               
113:                   const_vel[0] = 1;
0012DA  200000     MOV #0x0, W0
0012DC  23F801     MOV #0x3F80, W1
0012DE  884B00     MOV W0, const_vel
0012E0  884B11     MOV W1, 0x962
114:               
115:                   enable_motors = false;
0012E2  2094E1     MOV #0x94E, W1
0012E4  EB4000     CLR.B W0
0012E6  784880     MOV.B W0, [W1]
116:               }
0012E8  FA8000     ULNK
0012EA  060000     RETURN
117:               
118:               void update_parameter(void) {
0012EC  FA0000     LNK #0x0
119:                   parameter_int.radius_l = ((int) (parameter.radius_l * 1000.0));
0012EE  8047F0     MOV 0x8FE, W0
0012F0  804801     MOV 0x900, W1
0012F2  200002     MOV #0x0, W2
0012F4  2447A3     MOV #0x447A, W3
0012F6  07FB0E     RCALL ___mulsf3
0012F8  07FA43     RCALL ___fixsfsi
0012FA  780000     MOV W0, W0
0012FC  DE80CF     ASR W0, #15, W1
0012FE  884BC0     MOV W0, parameter_int
001300  884BD1     MOV W1, 0x97A
120:                   parameter_int.radius_r = ((int) (parameter.radius_r * 1000.0));
001302  8047D0     MOV parameter, W0
001304  8047E1     MOV 0x8FC, W1
001306  200002     MOV #0x0, W2
001308  2447A3     MOV #0x447A, W3
00130A  07FB04     RCALL ___mulsf3
00130C  07FA39     RCALL ___fixsfsi
00130E  780000     MOV W0, W0
001310  DE80CF     ASR W0, #15, W1
001312  884BE0     MOV W0, 0x97C
001314  884BF1     MOV W1, 0x97E
121:                   parameter_int.wheelbase = ((int) (parameter.wheelbase * 1000.0));
001316  804810     MOV 0x902, W0
001318  804821     MOV 0x904, W1
00131A  200002     MOV #0x0, W2
00131C  2447A3     MOV #0x447A, W3
00131E  07FAFA     RCALL ___mulsf3
001320  07FA2F     RCALL ___fixsfsi
001322  780000     MOV W0, W0
001324  DE80CF     ASR W0, #15, W1
001326  884C00     MOV W0, 0x980
001328  884C11     MOV W1, 0x982
122:                   parameter_int.k_vel_r = parameter.k_vel_r;
00132A  804830     MOV 0x906, W0
00132C  804841     MOV 0x908, W1
00132E  07FA28     RCALL ___fixsfsi
001330  884C40     MOV W0, 0x988
001332  884C51     MOV W1, 0x98A
123:                   parameter_int.k_vel_l = parameter.k_vel_l;
001334  804850     MOV 0x90A, W0
001336  804861     MOV 0x90C, W1
001338  07FA23     RCALL ___fixsfsi
00133A  884C20     MOV W0, 0x984
00133C  884C31     MOV W1, 0x986
124:                   k_odo.k_left = parameter.radius_l * parameter.k_ang_l;
00133E  8047F4     MOV 0x8FE, W4
001340  804805     MOV 0x900, W5
001342  804890     MOV 0x912, W0
001344  8048A1     MOV 0x914, W1
001346  BE0100     MOV.D W0, W2
001348  BE0004     MOV.D W4, W0
00134A  07FAE4     RCALL ___mulsf3
00134C  2096C2     MOV #0x96C, W2
00134E  BE8900     MOV.D W0, [W2]
125:                   k_odo.k_right = parameter.radius_r * parameter.k_ang_r;
001350  8047D4     MOV parameter, W4
001352  8047E5     MOV 0x8FC, W5
001354  804870     MOV 0x90E, W0
001356  804881     MOV 0x910, W1
001358  BE0100     MOV.D W0, W2
00135A  BE0004     MOV.D W4, W0
00135C  07FADB     RCALL ___mulsf3
00135E  2096C2     MOV #0x96C, W2
001360  980120     MOV W0, [W2+4]
001362  980131     MOV W1, [W2+6]
126:                   wheel_m = parameter.wheelbase / 2;
001364  804810     MOV 0x902, W0
001366  804821     MOV 0x904, W1
001368  200002     MOV #0x0, W2
00136A  240003     MOV #0x4000, W3
00136C  07F9B4     RCALL ___divsf3
00136E  884BA0     MOV W0, wheel_m
001370  884BB1     MOV W1, 0x976
127:               }
001372  FA8000     ULNK
001374  060000     RETURN
128:               
129:               void init_pid_control(void) {
001376  FA0000     LNK #0x0
130:                   pid_left.kp = 0.6;
001378  2999A0     MOV #0x999A, W0
00137A  23F191     MOV #0x3F19, W1
00137C  8849B0     MOV W0, pid_left
00137E  8849C1     MOV W1, 0x938
131:                   pid_left.ki = 0.7;
001380  233330     MOV #0x3333, W0
001382  23F331     MOV #0x3F33, W1
001384  8849D0     MOV W0, 0x93A
001386  8849E1     MOV W1, 0x93C
132:                   pid_left.kd = 0.1;
001388  2CCCD0     MOV #0xCCCD, W0
00138A  23DCC1     MOV #0x3DCC, W1
00138C  8849F0     MOV W0, 0x93E
00138E  884A01     MOV W1, 0x940
133:                   pid_right.kp = 0.6;
001390  2999A0     MOV #0x999A, W0
001392  23F191     MOV #0x3F19, W1
001394  884A10     MOV W0, pid_right
001396  884A21     MOV W1, 0x944
134:                   pid_right.ki = 0.7;
001398  233330     MOV #0x3333, W0
00139A  23F331     MOV #0x3F33, W1
00139C  884A30     MOV W0, 0x946
00139E  884A41     MOV W1, 0x948
135:                   pid_right.kd = 0.1;
0013A0  2CCCD0     MOV #0xCCCD, W0
0013A2  23DCC1     MOV #0x3DCC, W1
0013A4  884A50     MOV W0, 0x94A
0013A6  884A61     MOV W1, 0x94C
136:               }
0013A8  FA8000     ULNK
0013AA  060000     RETURN
137:               
138:               void update_pid_l(void) {
0013AC  FA0000     LNK #0x0
0013AE  781F88     MOV W8, [W15++]
139:                   kCoeffs1[0] = Q15(pid_left.kp); //0.5
0013B0  8049B0     MOV pid_left, W0
0013B2  8049C1     MOV 0x938, W1
0013B4  B3C018     MOV #0x1, W8
0013B6  B81160     MUL.UU W2, #0, W2
0013B8  07F9DF     RCALL ___lesf2
0013BA  500FE0     SUB W0, #0x0, [W15]
0013BC  350001     BRA LT, 0x13C0
0013BE  EB4400     CLR.B W8
0013C0  544FE0     SUB.B W8, #0x0, [W15]
0013C2  32000B     BRA Z, 0x13DA
0013C4  8049B0     MOV pid_left, W0
0013C6  8049C1     MOV 0x938, W1
0013C8  200002     MOV #0x0, W2
0013CA  247003     MOV #0x4700, W3
0013CC  07FAA3     RCALL ___mulsf3
0013CE  200002     MOV #0x0, W2
0013D0  23F003     MOV #0x3F00, W3
0013D2  07F921     RCALL ___subsf3
0013D4  07F9D5     RCALL ___fixsfsi
0013D6  780000     MOV W0, W0
0013D8  37000A     BRA 0x13EE
0013DA  8049B0     MOV pid_left, W0
0013DC  8049C1     MOV 0x938, W1
0013DE  2FE002     MOV #0xFE00, W2
0013E0  246FF3     MOV #0x46FF, W3
0013E2  07FA98     RCALL ___mulsf3
0013E4  200002     MOV #0x0, W2
0013E6  23F003     MOV #0x3F00, W3
0013E8  07F917     RCALL ___addsf3
0013EA  07F9CA     RCALL ___fixsfsi
0013EC  780000     MOV W0, W0
0013EE  884720     MOV W0, kCoeffs1
140:                   kCoeffs1[1] = Q15(pid_left.ki); //0.6
0013F0  8049D0     MOV 0x93A, W0
0013F2  8049E1     MOV 0x93C, W1
0013F4  B3C018     MOV #0x1, W8
0013F6  B81160     MUL.UU W2, #0, W2
0013F8  07F9BF     RCALL ___lesf2
0013FA  500FE0     SUB W0, #0x0, [W15]
0013FC  350001     BRA LT, 0x1400
0013FE  EB4400     CLR.B W8
001400  544FE0     SUB.B W8, #0x0, [W15]
001402  32000B     BRA Z, 0x141A
001404  8049D0     MOV 0x93A, W0
001406  8049E1     MOV 0x93C, W1
001408  200002     MOV #0x0, W2
00140A  247003     MOV #0x4700, W3
00140C  07FA83     RCALL ___mulsf3
00140E  200002     MOV #0x0, W2
001410  23F003     MOV #0x3F00, W3
001412  07F901     RCALL ___subsf3
001414  07F9B5     RCALL ___fixsfsi
001416  780000     MOV W0, W0
001418  37000A     BRA 0x142E
00141A  8049D0     MOV 0x93A, W0
00141C  8049E1     MOV 0x93C, W1
00141E  2FE002     MOV #0xFE00, W2
001420  246FF3     MOV #0x46FF, W3
001422  07FA78     RCALL ___mulsf3
001424  200002     MOV #0x0, W2
001426  23F003     MOV #0x3F00, W3
001428  07F8F7     RCALL ___addsf3
00142A  07F9AA     RCALL ___fixsfsi
00142C  780000     MOV W0, W0
00142E  884730     MOV W0, 0x8E6
141:                   kCoeffs1[2] = Q15(pid_left.kp); //0.0
001430  8049B0     MOV pid_left, W0
001432  8049C1     MOV 0x938, W1
001434  B3C018     MOV #0x1, W8
001436  B81160     MUL.UU W2, #0, W2
001438  07F99F     RCALL ___lesf2
00143A  500FE0     SUB W0, #0x0, [W15]
00143C  350001     BRA LT, 0x1440
00143E  EB4400     CLR.B W8
001440  544FE0     SUB.B W8, #0x0, [W15]
001442  32000B     BRA Z, 0x145A
001444  8049B0     MOV pid_left, W0
001446  8049C1     MOV 0x938, W1
001448  200002     MOV #0x0, W2
00144A  247003     MOV #0x4700, W3
00144C  07FA63     RCALL ___mulsf3
00144E  200002     MOV #0x0, W2
001450  23F003     MOV #0x3F00, W3
001452  07F8E1     RCALL ___subsf3
001454  07F995     RCALL ___fixsfsi
001456  780000     MOV W0, W0
001458  37000A     BRA 0x146E
00145A  8049B0     MOV pid_left, W0
00145C  8049C1     MOV 0x938, W1
00145E  2FE002     MOV #0xFE00, W2
001460  246FF3     MOV #0x46FF, W3
001462  07FA58     RCALL ___mulsf3
001464  200002     MOV #0x0, W2
001466  23F003     MOV #0x3F00, W3
001468  07F8D7     RCALL ___addsf3
00146A  07F98A     RCALL ___fixsfsi
00146C  780000     MOV W0, W0
00146E  884740     MOV W0, 0x8E8
142:                   InitPid1(); //Init PIDL
001470  070069     RCALL InitPid1
143:               }
001472  78044F     MOV [--W15], W8
001474  FA8000     ULNK
001476  060000     RETURN
144:               
145:               void update_pid_r(void) {
001478  FA0000     LNK #0x0
00147A  781F88     MOV W8, [W15++]
146:                   kCoeffs2[0] = Q15(pid_right.kp);
00147C  804A10     MOV pid_right, W0
00147E  804A21     MOV 0x944, W1
001480  B3C018     MOV #0x1, W8
001482  B81160     MUL.UU W2, #0, W2
001484  07F979     RCALL ___lesf2
001486  500FE0     SUB W0, #0x0, [W15]
001488  350001     BRA LT, 0x148C
00148A  EB4400     CLR.B W8
00148C  544FE0     SUB.B W8, #0x0, [W15]
00148E  32000B     BRA Z, 0x14A6
001490  804A10     MOV pid_right, W0
001492  804A21     MOV 0x944, W1
001494  200002     MOV #0x0, W2
001496  247003     MOV #0x4700, W3
001498  07FA3D     RCALL ___mulsf3
00149A  200002     MOV #0x0, W2
00149C  23F003     MOV #0x3F00, W3
00149E  07F8BB     RCALL ___subsf3
0014A0  07F96F     RCALL ___fixsfsi
0014A2  780000     MOV W0, W0
0014A4  37000A     BRA 0x14BA
0014A6  804A10     MOV pid_right, W0
0014A8  804A21     MOV 0x944, W1
0014AA  2FE002     MOV #0xFE00, W2
0014AC  246FF3     MOV #0x46FF, W3
0014AE  07FA32     RCALL ___mulsf3
0014B0  200002     MOV #0x0, W2
0014B2  23F003     MOV #0x3F00, W3
0014B4  07F8B1     RCALL ___addsf3
0014B6  07F964     RCALL ___fixsfsi
0014B8  780000     MOV W0, W0
0014BA  8847A0     MOV W0, kCoeffs2
147:                   kCoeffs2[1] = Q15(pid_right.ki);
0014BC  804A30     MOV 0x946, W0
0014BE  804A41     MOV 0x948, W1
0014C0  B3C018     MOV #0x1, W8
0014C2  B81160     MUL.UU W2, #0, W2
0014C4  07F959     RCALL ___lesf2
0014C6  500FE0     SUB W0, #0x0, [W15]
0014C8  350001     BRA LT, 0x14CC
0014CA  EB4400     CLR.B W8
0014CC  544FE0     SUB.B W8, #0x0, [W15]
0014CE  32000B     BRA Z, 0x14E6
0014D0  804A30     MOV 0x946, W0
0014D2  804A41     MOV 0x948, W1
0014D4  200002     MOV #0x0, W2
0014D6  247003     MOV #0x4700, W3
0014D8  07FA1D     RCALL ___mulsf3
0014DA  200002     MOV #0x0, W2
0014DC  23F003     MOV #0x3F00, W3
0014DE  07F89B     RCALL ___subsf3
0014E0  07F94F     RCALL ___fixsfsi
0014E2  780000     MOV W0, W0
0014E4  37000A     BRA 0x14FA
0014E6  804A30     MOV 0x946, W0
0014E8  804A41     MOV 0x948, W1
0014EA  2FE002     MOV #0xFE00, W2
0014EC  246FF3     MOV #0x46FF, W3
0014EE  07FA12     RCALL ___mulsf3
0014F0  200002     MOV #0x0, W2
0014F2  23F003     MOV #0x3F00, W3
0014F4  07F891     RCALL ___addsf3
0014F6  07F944     RCALL ___fixsfsi
0014F8  780000     MOV W0, W0
0014FA  8847B0     MOV W0, 0x8F6
148:                   kCoeffs2[2] = Q15(pid_right.kd);
0014FC  804A50     MOV 0x94A, W0
0014FE  804A61     MOV 0x94C, W1
001500  B3C018     MOV #0x1, W8
001502  B81160     MUL.UU W2, #0, W2
001504  07F939     RCALL ___lesf2
001506  500FE0     SUB W0, #0x0, [W15]
001508  350001     BRA LT, 0x150C
00150A  EB4400     CLR.B W8
00150C  544FE0     SUB.B W8, #0x0, [W15]
00150E  32000B     BRA Z, 0x1526
001510  804A50     MOV 0x94A, W0
001512  804A61     MOV 0x94C, W1
001514  200002     MOV #0x0, W2
001516  247003     MOV #0x4700, W3
001518  07F9FD     RCALL ___mulsf3
00151A  200002     MOV #0x0, W2
00151C  23F003     MOV #0x3F00, W3
00151E  07F87B     RCALL ___subsf3
001520  07F92F     RCALL ___fixsfsi
001522  780000     MOV W0, W0
001524  37000A     BRA 0x153A
001526  804A50     MOV 0x94A, W0
001528  804A61     MOV 0x94C, W1
00152A  2FE002     MOV #0xFE00, W2
00152C  246FF3     MOV #0x46FF, W3
00152E  07F9F2     RCALL ___mulsf3
001530  200002     MOV #0x0, W2
001532  23F003     MOV #0x3F00, W3
001534  07F871     RCALL ___addsf3
001536  07F924     RCALL ___fixsfsi
001538  780000     MOV W0, W0
00153A  8847C0     MOV W0, 0x8F8
149:                   InitPid2(); //Init PIDR
00153C  07000F     RCALL InitPid2
150:               }
00153E  78044F     MOV [--W15], W8
001540  FA8000     ULNK
001542  060000     RETURN
151:               
152:               void InitPid1(void) {
001544  FA0000     LNK #0x0
153:                   //Initialize the PID data structure: PIDstruct
154:                   //Set up pointer to derived coefficients
155:                   PIDstruct1.abcCoefficients = &abcCoefficient1[0];
001546  208000     MOV #0x800, W0
001548  8846D0     MOV W0, PIDstruct1
156:                   //Set up pointer to controller history samples
157:                   PIDstruct1.controlHistory = &controlHistory1[0];
00154A  247C80     MOV #0x47C8, W0
00154C  8846E0     MOV W0, 0x8DC
158:                   // Clear the controler history and the controller output
159:                   PIDInit(&PIDstruct1);
00154E  208DA0     MOV #0x8DA, W0
001550  07F811     RCALL _PIDInit
160:                   //Derive the a,b, & c coefficients from the Kp, Ki & Kd
161:                   PIDCoeffCalc(&kCoeffs1[0], &PIDstruct1);
001552  208DA1     MOV #0x8DA, W1
001554  208E40     MOV #0x8E4, W0
001556  07F819     RCALL _PIDCoeffCalc
162:               }
001558  FA8000     ULNK
00155A  060000     RETURN
163:               
164:               void InitPid2(void) {
00155C  FA0000     LNK #0x0
165:                   //Initialize the PID data structure: PIDstruct
166:                   //Set up pointer to derived coefficients
167:                   PIDstruct2.abcCoefficients = &abcCoefficient2[0];
00155E  208060     MOV #0x806, W0
001560  884750     MOV W0, PIDstruct2
168:                   //Set up pointer to controller history samples
169:                   PIDstruct2.controlHistory = &controlHistory2[0];
001562  247CE0     MOV #0x47CE, W0
001564  884760     MOV W0, 0x8EC
170:                   // Clear the controler history and the controller output
171:                   PIDInit(&PIDstruct2);
001566  208EA0     MOV #0x8EA, W0
001568  07F805     RCALL _PIDInit
172:                   //Derive the a,b, & c coefficients from the Kp, Ki & Kd
173:                   PIDCoeffCalc(&kCoeffs2[0], &PIDstruct2);
00156A  208EA1     MOV #0x8EA, W1
00156C  208F40     MOV #0x8F4, W0
00156E  07F80D     RCALL _PIDCoeffCalc
174:               }
001570  FA8000     ULNK
001572  060000     RETURN
175:               
176:               int Velocity(void) {
001574  FA000E     LNK #0xE
001576  BE9F88     MOV.D W8, [W15++]
001578  BE9F8A     MOV.D W10, [W15++]
177:                   unsigned int t = TMR1; // Timing function
00157A  800800     MOV TMR1, W0
00157C  780F00     MOV W0, [W14]
178:                   int rifer_con_left, rifer_con_right;
179:                   MOTOR_ENABLE1 = enable_motors;
00157E  2094E0     MOV #0x94E, W0
001580  784010     MOV.B [W0], W0
001582  604061     AND.B W0, #0x1, W0
001584  FB8000     ZE W0, W0
001586  600061     AND W0, #0x1, W0
001588  DD0042     SL W0, #2, W0
00158A  801662     MOV LATB, W2
00158C  2FFFB1     MOV #0xFFFB, W1
00158E  610081     AND W2, W1, W1
001590  708000     IOR W1, W0, W0
001592  881660     MOV W0, LATB
180:                   MOTOR_ENABLE2 = enable_motors;
001594  2094E0     MOV #0x94E, W0
001596  784010     MOV.B [W0], W0
001598  604061     AND.B W0, #0x1, W0
00159A  FB8000     ZE W0, W0
00159C  600061     AND W0, #0x1, W0
00159E  DD0043     SL W0, #3, W0
0015A0  801662     MOV LATB, W2
0015A2  2FFF71     MOV #0xFFF7, W1
0015A4  610081     AND W2, W1, W1
0015A6  708000     IOR W1, W0, W0
0015A8  881660     MOV W0, LATB
181:                   long vel_v = (parameter_int.radius_r * motor_right.measure_vel + parameter_int.radius_l * motor_left.measure_vel) / 2;
0015AA  804BE2     MOV 0x97C, W2
0015AC  804BF3     MOV 0x97E, W3
0015AE  209580     MOV #0x958, W0
0015B0  900020     MOV [W0+4], W0
0015B2  DE80CF     ASR W0, #15, W1
0015B4  B99A00     MUL.SS W3, W0, W4
0015B6  780204     MOV W4, W4
0015B8  B98B02     MUL.SS W1, W2, W6
0015BA  780286     MOV W6, W5
0015BC  420205     ADD W4, W5, W4
0015BE  B81100     MUL.UU W2, W0, W2
0015C0  420203     ADD W4, W3, W4
0015C2  780184     MOV W4, W3
0015C4  804BC4     MOV parameter_int, W4
0015C6  804BD5     MOV 0x97A, W5
0015C8  209500     MOV #0x950, W0
0015CA  900020     MOV [W0+4], W0
0015CC  DE80CF     ASR W0, #15, W1
0015CE  B9AB00     MUL.SS W5, W0, W6
0015D0  780306     MOV W6, W6
0015D2  B98C04     MUL.SS W1, W4, W8
0015D4  780388     MOV W8, W7
0015D6  430307     ADD W6, W7, W6
0015D8  B82000     MUL.UU W4, W0, W0
0015DA  430301     ADD W6, W1, W6
0015DC  780086     MOV W6, W1
0015DE  400002     ADD W0, W2, W0
0015E0  488083     ADDC W1, W3, W1
0015E2  DE094F     LSR W1, #15, W2
0015E4  200003     MOV #0x0, W3
0015E6  400002     ADD W0, W2, W0
0015E8  488083     ADDC W1, W3, W1
0015EA  D18081     ASR W1, W1
0015EC  D38000     RRC W0, W0
0015EE  980710     MOV W0, [W14+2]
0015F0  980721     MOV W1, [W14+4]
182:                   long vel_w = -(parameter_int.radius_r * motor_right.measure_vel - parameter_int.radius_l * motor_left.measure_vel) / (2 * parameter_int.wheelbase);
0015F2  804BC2     MOV parameter_int, W2
0015F4  804BD3     MOV 0x97A, W3
0015F6  209500     MOV #0x950, W0
0015F8  900020     MOV [W0+4], W0
0015FA  DE80CF     ASR W0, #15, W1
0015FC  B99A00     MUL.SS W3, W0, W4
0015FE  780204     MOV W4, W4
001600  B98B02     MUL.SS W1, W2, W6
001602  780286     MOV W6, W5
001604  420205     ADD W4, W5, W4
001606  B81100     MUL.UU W2, W0, W2
001608  420203     ADD W4, W3, W4
00160A  780184     MOV W4, W3
00160C  804BE4     MOV 0x97C, W4
00160E  804BF5     MOV 0x97E, W5
001610  209580     MOV #0x958, W0
001612  900020     MOV [W0+4], W0
001614  DE80CF     ASR W0, #15, W1
001616  B9AB00     MUL.SS W5, W0, W6
001618  780306     MOV W6, W6
00161A  B98C04     MUL.SS W1, W4, W8
00161C  780388     MOV W8, W7
00161E  430307     ADD W6, W7, W6
001620  B82000     MUL.UU W4, W0, W0
001622  430301     ADD W6, W1, W6
001624  780086     MOV W6, W1
001626  510200     SUB W2, W0, W4
001628  598281     SUBB W3, W1, W5
00162A  804C00     MOV 0x980, W0
00162C  804C11     MOV 0x982, W1
00162E  400000     ADD W0, W0, W0
001630  488081     ADDC W1, W1, W1
001632  BE0100     MOV.D W0, W2
001634  BE0004     MOV.D W4, W0
001636  07F891     RCALL ___divsi3
001638  980730     MOV W0, [W14+6]
00163A  980741     MOV W1, [W14+8]
183:                   vel_mis.v = ((float) vel_v / 1000000);
00163C  90001E     MOV [W14+2], W0
00163E  9000AE     MOV [W14+4], W1
001640  07F8C0     RCALL ___floatsisf
001642  224002     MOV #0x2400, W2
001644  249743     MOV #0x4974, W3
001646  07F847     RCALL ___divsf3
001648  2092E2     MOV #0x92E, W2
00164A  BE8900     MOV.D W0, [W2]
184:                   vel_mis.w = ((float) vel_w / 1000);
00164C  90003E     MOV [W14+6], W0
00164E  9000CE     MOV [W14+8], W1
001650  07F8B8     RCALL ___floatsisf
001652  200002     MOV #0x0, W2
001654  2447A3     MOV #0x447A, W3
001656  07F83F     RCALL ___divsf3
001658  2092E2     MOV #0x92E, W2
00165A  980120     MOV W0, [W2+4]
00165C  980131     MOV W1, [W2+6]
185:               
186:                   rifer_con_left = (int) ((1 / parameter.radius_r)*(vel_rif.v + (parameter.wheelbase * vel_rif.w))*1000);
00165E  8047D0     MOV parameter, W0
001660  8047E1     MOV 0x8FC, W1
001662  BE0100     MOV.D W0, W2
001664  200000     MOV #0x0, W0
001666  23F801     MOV #0x3F80, W1
001668  07F836     RCALL ___divsf3
00166A  BE0400     MOV.D W0, W8
00166C  209260     MOV #0x926, W0
00166E  BE0510     MOV.D [W0], W10
001670  804814     MOV 0x902, W4
001672  804825     MOV 0x904, W5
001674  209260     MOV #0x926, W0
001676  9000B0     MOV [W0+6], W1
001678  900020     MOV [W0+4], W0
00167A  BE0100     MOV.D W0, W2
00167C  BE0004     MOV.D W4, W0
00167E  07F94A     RCALL ___mulsf3
001680  BE0100     MOV.D W0, W2
001682  BE000A     MOV.D W10, W0
001684  07F7C9     RCALL ___addsf3
001686  BE0100     MOV.D W0, W2
001688  BE0008     MOV.D W8, W0
00168A  07F944     RCALL ___mulsf3
00168C  200002     MOV #0x0, W2
00168E  2447A3     MOV #0x447A, W3
001690  07F941     RCALL ___mulsf3
001692  07F876     RCALL ___fixsfsi
001694  980750     MOV W0, [W14+10]
187:                   rifer_con_right = (int) ((1 / parameter.radius_l)*(vel_rif.v - (parameter.wheelbase * vel_rif.w))*1000);
001696  8047F0     MOV 0x8FE, W0
001698  804801     MOV 0x900, W1
00169A  BE0100     MOV.D W0, W2
00169C  200000     MOV #0x0, W0
00169E  23F801     MOV #0x3F80, W1
0016A0  07F81A     RCALL ___divsf3
0016A2  BE0400     MOV.D W0, W8
0016A4  209260     MOV #0x926, W0
0016A6  BE0510     MOV.D [W0], W10
0016A8  804814     MOV 0x902, W4
0016AA  804825     MOV 0x904, W5
0016AC  209260     MOV #0x926, W0
0016AE  9000B0     MOV [W0+6], W1
0016B0  900020     MOV [W0+4], W0
0016B2  BE0100     MOV.D W0, W2
0016B4  BE0004     MOV.D W4, W0
0016B6  07F92E     RCALL ___mulsf3
0016B8  BE0100     MOV.D W0, W2
0016BA  BE000A     MOV.D W10, W0
0016BC  07F7AC     RCALL ___subsf3
0016BE  BE0100     MOV.D W0, W2
0016C0  BE0008     MOV.D W8, W0
0016C2  07F928     RCALL ___mulsf3
0016C4  200002     MOV #0x0, W2
0016C6  2447A3     MOV #0x447A, W3
0016C8  07F925     RCALL ___mulsf3
0016CA  07F85A     RCALL ___fixsfsi
0016CC  980760     MOV W0, [W14+12]
188:                   // Calculating constraint
189:                   if (abs(rifer_con_left) > constraint.max_left) {
0016CE  90005E     MOV [W14+10], W0
0016D0  500FE0     SUB W0, #0x0, [W15]
0016D2  3D0001     BRA GE, 0x16D6
0016D4  EA0000     NEG W0, W0
0016D6  DE80CF     ASR W0, #15, W1
0016D8  07F874     RCALL ___floatsisf
0016DA  BE0200     MOV.D W0, W4
0016DC  2091E0     MOV #0x91E, W0
0016DE  BE0010     MOV.D [W0], W0
0016E0  B3C018     MOV #0x1, W8
0016E2  BE0100     MOV.D W0, W2
0016E4  BE0004     MOV.D W4, W0
0016E6  07F84A     RCALL ___gtsf2
0016E8  500FE0     SUB W0, #0x0, [W15]
0016EA  3C0001     BRA GT, 0x16EE
0016EC  EB4400     CLR.B W8
0016EE  544FE0     SUB.B W8, #0x0, [W15]
0016F0  320007     BRA Z, 0x1700
190:                       motor_left.rifer_vel = constraint.max_left;
0016F2  2091E0     MOV #0x91E, W0
0016F4  BE0010     MOV.D [W0], W0
0016F6  07F844     RCALL ___fixsfsi
0016F8  780080     MOV W0, W1
0016FA  209500     MOV #0x950, W0
0016FC  780801     MOV W1, [W0]
0016FE  370003     BRA 0x1706
191:                   } else {
192:                       motor_left.rifer_vel = rifer_con_left;
001700  209500     MOV #0x950, W0
001702  9000DE     MOV [W14+10], W1
001704  780801     MOV W1, [W0]
193:                   }
194:                   if (abs(rifer_con_right) > constraint.max_right) {
001706  90006E     MOV [W14+12], W0
001708  500FE0     SUB W0, #0x0, [W15]
00170A  3D0001     BRA GE, 0x170E
00170C  EA0000     NEG W0, W0
00170E  DE80CF     ASR W0, #15, W1
001710  07F858     RCALL ___floatsisf
001712  BE0200     MOV.D W0, W4
001714  2091E0     MOV #0x91E, W0
001716  9000B0     MOV [W0+6], W1
001718  900020     MOV [W0+4], W0
00171A  B3C018     MOV #0x1, W8
00171C  BE0100     MOV.D W0, W2
00171E  BE0004     MOV.D W4, W0
001720  07F82D     RCALL ___gtsf2
001722  500FE0     SUB W0, #0x0, [W15]
001724  3C0001     BRA GT, 0x1728
001726  EB4400     CLR.B W8
001728  544FE0     SUB.B W8, #0x0, [W15]
00172A  320008     BRA Z, 0x173C
195:                       motor_right.rifer_vel = constraint.max_right;
00172C  2091E0     MOV #0x91E, W0
00172E  9000B0     MOV [W0+6], W1
001730  900020     MOV [W0+4], W0
001732  07F826     RCALL ___fixsfsi
001734  780080     MOV W0, W1
001736  209580     MOV #0x958, W0
001738  780801     MOV W1, [W0]
00173A  370003     BRA 0x1742
196:                   } else {
197:                       motor_right.rifer_vel = rifer_con_right;
00173C  209580     MOV #0x958, W0
00173E  9000EE     MOV [W14+12], W1
001740  780801     MOV W1, [W0]
198:                   }
199:                   return TMR1 - t; // Time of esecution
001742  800800     MOV TMR1, W0
001744  50001E     SUB W0, [W14], W0
200:               }
001746  BE054F     MOV.D [--W15], W10
001748  BE044F     MOV.D [--W15], W8
00174A  FA8000     ULNK
00174C  060000     RETURN
201:               
202:               int MotorPIDL(void) {
00174E  FA0008     LNK #0x8
001750  BE9F88     MOV.D W8, [W15++]
001752  BE9F8A     MOV.D W10, [W15++]
203:                   unsigned int t = TMR1; //Timing funzione
001754  800800     MOV TMR1, W0
001756  780F00     MOV W0, [W14]
204:                   unsigned long timePeriodLtmp; //Variabili temporanee Periodo
205:                   int SIG_VELLtmp; //Segno velocit
206:               
207:                   timePeriodLtmp = timePeriodL; //Salvataggio TimerPeriod
001758  804D60     MOV 0x9AC, W0
00175A  804D71     MOV 0x9AE, W1
00175C  980710     MOV W0, [W14+2]
00175E  980721     MOV W1, [W14+4]
208:                   timePeriodL = 0; //Pulizia variabile
001760  B80060     MUL.UU W0, #0, W0
001762  884D60     MOV W0, 0x9AC
001764  884D71     MOV W1, 0x9AE
209:                   SIG_VELLtmp = SIG_VELL; //Salvataggio Segno velocit
001766  804DA0     MOV 0x9B4, W0
001768  980730     MOV W0, [W14+6]
210:                   SIG_VELL = 0; //Pulizia variabile
00176A  EB0000     CLR W0
00176C  884DA0     MOV W0, 0x9B4
211:                   motor_left.measure_vel = 0; //Flush variaibile velocit R
00176E  209500     MOV #0x950, W0
001770  EB0080     CLR W1
001772  980021     MOV W1, [W0+4]
212:               
213:                   PulsEncL += (int) POS1CNT; //Salvataggio spazio percorso
001774  804E61     MOV 0x9CC, W1
001776  800F20     MOV POS1CNT, W0
001778  408000     ADD W1, W0, W0
00177A  884E60     MOV W0, 0x9CC
214:                   POS1CNT = 0; //Reset registro
00177C  EB0000     CLR W0
00177E  880F20     MOV W0, POS1CNT
215:                   //calcolo della velocit
216:                   //Verifica SIG_VELLtmp!=0 & calcolo velocit
217:                   if (SIG_VELLtmp) motor_left.measure_vel = SIG_VELLtmp * (parameter.k_vel_l / timePeriodLtmp);
001780  90003E     MOV [W14+6], W0
001782  500FE0     SUB W0, #0x0, [W15]
001784  320013     BRA Z, 0x17AC
001786  90003E     MOV [W14+6], W0
001788  DE80CF     ASR W0, #15, W1
00178A  07F81B     RCALL ___floatsisf
00178C  BE0400     MOV.D W0, W8
00178E  80485A     MOV 0x90A, W10
001790  80486B     MOV 0x90C, W11
001792  90001E     MOV [W14+2], W0
001794  9000AE     MOV [W14+4], W1
001796  07F818     RCALL ___floatunsisf
001798  BE0100     MOV.D W0, W2
00179A  BE000A     MOV.D W10, W0
00179C  07F79C     RCALL ___divsf3
00179E  BE0100     MOV.D W0, W2
0017A0  BE0008     MOV.D W8, W0
0017A2  07F8B8     RCALL ___mulsf3
0017A4  07F7ED     RCALL ___fixsfsi
0017A6  780080     MOV W0, W1
0017A8  209500     MOV #0x950, W0
0017AA  980021     MOV W1, [W0+4]
218:                   PIDstruct1.controlReference = -motor_left.rifer_vel; //Riferimento Ruota Sinistra
0017AC  209500     MOV #0x950, W0
0017AE  780010     MOV [W0], W0
0017B0  EA0000     NEG W0, W0
0017B2  884710     MOV W0, 0x8E2
219:                   PIDstruct1.measuredOutput = -motor_left.measure_vel; //Misura velocit
0017B4  209500     MOV #0x950, W0
0017B6  900020     MOV [W0+4], W0
0017B8  EA0000     NEG W0, W0
0017BA  884700     MOV W0, 0x8E0
220:                   PID(&PIDstruct1); //Esecuzione funzione PID
0017BC  208DA0     MOV #0x8DA, W0
0017BE  07F6BE     RCALL _PID
221:                   motor_left.control_vel = (PIDstruct1.controlOutput >> 4) + 2049; //Conversione valore per PWM
0017C0  8046F0     MOV 0x8DE, W0
0017C2  DE80C4     ASR W0, #4, W1
0017C4  208010     MOV #0x801, W0
0017C6  408080     ADD W1, W0, W1
0017C8  209500     MOV #0x950, W0
0017CA  980011     MOV W1, [W0+2]
222:                   //Invio dell'azione di controllo al motore per mezzo del PWM
223:                   SetDCMCPWM1(1, motor_left.control_vel, 0);
0017CC  209500     MOV #0x950, W0
0017CE  900010     MOV [W0+2], W0
0017D0  EB4100     CLR.B W2
0017D2  780080     MOV W0, W1
0017D4  200010     MOV #0x1, W0
0017D6  07F713     RCALL _SetDCMCPWM1
224:               
225:                   return TMR1 - t; //Misura tempo di esecuzione
0017D8  800800     MOV TMR1, W0
0017DA  50001E     SUB W0, [W14], W0
226:               }
0017DC  BE054F     MOV.D [--W15], W10
0017DE  BE044F     MOV.D [--W15], W8
0017E0  FA8000     ULNK
0017E2  060000     RETURN
227:               
228:               int MotorPIDR(void) {
0017E4  FA0008     LNK #0x8
0017E6  BE9F88     MOV.D W8, [W15++]
0017E8  BE9F8A     MOV.D W10, [W15++]
229:                   unsigned int t = TMR1; //Timing funzione
0017EA  800800     MOV TMR1, W0
0017EC  780F00     MOV W0, [W14]
230:                   unsigned long timePeriodRtmp; //Variabili temporanee Periodo
231:                   int SIG_VELRtmp; //Segno velocit
232:               
233:                   timePeriodRtmp = timePeriodR; //Salvataggio TimerPeriod
0017EE  804D80     MOV 0x9B0, W0
0017F0  804D91     MOV 0x9B2, W1
0017F2  980710     MOV W0, [W14+2]
0017F4  980721     MOV W1, [W14+4]
234:                   timePeriodR = 0; //Pulizia variabile
0017F6  B80060     MUL.UU W0, #0, W0
0017F8  884D80     MOV W0, 0x9B0
0017FA  884D91     MOV W1, 0x9B2
235:                   SIG_VELRtmp = SIG_VELR; //Salvataggio Segno velocit
0017FC  804DB0     MOV 0x9B6, W0
0017FE  980730     MOV W0, [W14+6]
236:                   SIG_VELR = 0; //Pulizia variabile
001800  EB0000     CLR W0
001802  884DB0     MOV W0, 0x9B6
237:                   motor_right.measure_vel = 0; //Flush variabile velocit R
001804  209580     MOV #0x958, W0
001806  EB0080     CLR W1
001808  980021     MOV W1, [W0+4]
238:               
239:                   PulsEncR += (int) POS2CNT; //Salvataggio spazio percorso
00180A  804E71     MOV 0x9CE, W1
00180C  800FA0     MOV POS2CNT, W0
00180E  408000     ADD W1, W0, W0
001810  884E70     MOV W0, 0x9CE
240:                   POS2CNT = 0; //Reset registro
001812  EB0000     CLR W0
001814  880FA0     MOV W0, POS2CNT
241:                   //calcolo della velocit
242:                   //Verifica SIG_VELLtmp!=0 & calcolo velocit
243:                   if (SIG_VELRtmp) motor_right.measure_vel = SIG_VELRtmp * (parameter.k_vel_r / timePeriodRtmp);
001816  90003E     MOV [W14+6], W0
001818  500FE0     SUB W0, #0x0, [W15]
00181A  320013     BRA Z, 0x1842
00181C  90003E     MOV [W14+6], W0
00181E  DE80CF     ASR W0, #15, W1
001820  07F7D0     RCALL ___floatsisf
001822  BE0400     MOV.D W0, W8
001824  80483A     MOV 0x906, W10
001826  80484B     MOV 0x908, W11
001828  90001E     MOV [W14+2], W0
00182A  9000AE     MOV [W14+4], W1
00182C  07F7CD     RCALL ___floatunsisf
00182E  BE0100     MOV.D W0, W2
001830  BE000A     MOV.D W10, W0
001832  07F751     RCALL ___divsf3
001834  BE0100     MOV.D W0, W2
001836  BE0008     MOV.D W8, W0
001838  07F86D     RCALL ___mulsf3
00183A  07F7A2     RCALL ___fixsfsi
00183C  780080     MOV W0, W1
00183E  209580     MOV #0x958, W0
001840  980021     MOV W1, [W0+4]
244:                   PIDstruct2.controlReference = motor_right.rifer_vel; //Riferimento Ruota Sinistra
001842  209580     MOV #0x958, W0
001844  780010     MOV [W0], W0
001846  884790     MOV W0, 0x8F2
245:                   PIDstruct2.measuredOutput = motor_right.measure_vel; //Misura velocit
001848  209580     MOV #0x958, W0
00184A  900020     MOV [W0+4], W0
00184C  884780     MOV W0, 0x8F0
246:                   PID(&PIDstruct2); //Esecuzione funzione PID
00184E  208EA0     MOV #0x8EA, W0
001850  07F675     RCALL _PID
247:                   motor_right.control_vel = (PIDstruct2.controlOutput >> 4) + 2049; //Conversione valore per PWM
001852  804770     MOV 0x8EE, W0
001854  DE80C4     ASR W0, #4, W1
001856  208010     MOV #0x801, W0
001858  408080     ADD W1, W0, W1
00185A  209580     MOV #0x958, W0
00185C  980011     MOV W1, [W0+2]
248:                   //Invio dell'azione di controllo al motore per mezzo del PWM
249:                   SetDCMCPWM1(2, motor_right.control_vel, 0);
00185E  209580     MOV #0x958, W0
001860  900010     MOV [W0+2], W0
001862  EB4100     CLR.B W2
001864  780080     MOV W0, W1
001866  200020     MOV #0x2, W0
001868  07F6CA     RCALL _SetDCMCPWM1
250:               
251:                   return TMR1 - t; //Misura tempo di esecuzione
00186A  800800     MOV TMR1, W0
00186C  50001E     SUB W0, [W14], W0
252:               }
00186E  BE054F     MOV.D [--W15], W10
001870  BE044F     MOV.D [--W15], W8
001872  FA8000     ULNK
001874  060000     RETURN
253:               
254:               void adc_motors_current(void) {
001876  FA000E     LNK #0xE
255:                   int SIG_VELLtmp, SIG_VELRtmp; //Segno velocit
256:                   int AdcCount = 0; //Contatore
001878  EB0000     CLR W0
00187A  780F00     MOV W0, [W14]
257:                   long ADCValueTmp[ADC_CHANNELS] = {0, 0}; //Valore temporaneo letture
00187C  B80060     MUL.UU W0, #0, W0
00187E  980730     MOV W0, [W14+6]
001880  980741     MOV W1, [W14+8]
001882  B80060     MUL.UU W0, #0, W0
001884  980750     MOV W0, [W14+10]
001886  980761     MOV W1, [W14+12]
258:               
259:                   for (AdcCount = 0; AdcCount < ADC_BUFF; AdcCount++) // Calcolo media di tutti i campioni
001888  EB0000     CLR W0
00188A  780F00     MOV W0, [W14]
00188C  37001A     BRA 0x18C2
0018C0  E80F1E     INC [W14], [W14]
0018C2  2003F0     MOV #0x3F, W0
0018C4  78009E     MOV [W14], W1
0018C6  508F80     SUB W1, W0, [W15]
0018C8  34FFE2     BRA LE, 0x188E
260:                   {
261:                       ADCValueTmp[0] += AdcBuffer[0][AdcCount]; //Sommatoria per AN0
00188E  90013E     MOV [W14+6], W2
001890  9001CE     MOV [W14+8], W3
001892  78001E     MOV [W14], W0
001894  400080     ADD W0, W0, W1
001896  246000     MOV #0x4600, W0
001898  408000     ADD W1, W0, W0
00189A  780010     MOV [W0], W0
00189C  DE80CF     ASR W0, #15, W1
00189E  400002     ADD W0, W2, W0
0018A0  488083     ADDC W1, W3, W1
0018A2  980730     MOV W0, [W14+6]
0018A4  980741     MOV W1, [W14+8]
262:                       ADCValueTmp[1] += AdcBuffer[1][AdcCount]; //Sommatoria per AN1
0018A6  90015E     MOV [W14+10], W2
0018A8  9001EE     MOV [W14+12], W3
0018AA  200401     MOV #0x40, W1
0018AC  40801E     ADD W1, [W14], W0
0018AE  400080     ADD W0, W0, W1
0018B0  246000     MOV #0x4600, W0
0018B2  408000     ADD W1, W0, W0
0018B4  780010     MOV [W0], W0
0018B6  DE80CF     ASR W0, #15, W1
0018B8  400002     ADD W0, W2, W0
0018BA  488083     ADDC W1, W3, W1
0018BC  980750     MOV W0, [W14+10]
0018BE  980761     MOV W1, [W14+12]
263:                   }
264:                   SIG_VELLtmp = SIG_VELL; //Salvataggio Segno velocit
0018CA  804DA0     MOV 0x9B4, W0
0018CC  980710     MOV W0, [W14+2]
265:                   SIG_VELRtmp = SIG_VELR; //Salvataggio Segno velocit
0018CE  804DB0     MOV 0x9B6, W0
0018D0  980720     MOV W0, [W14+4]
266:                   motor_left.current = SIG_VELRtmp * ADCValueTmp[0] >> 6; //Divisione o shifth
0018D2  90002E     MOV [W14+4], W0
0018D4  B90161     MUL.SU W0, #1, W2
0018D6  90003E     MOV [W14+6], W0
0018D8  9000CE     MOV [W14+8], W1
0018DA  B99A00     MUL.SS W3, W0, W4
0018DC  780204     MOV W4, W4
0018DE  B98B02     MUL.SS W1, W2, W6
0018E0  780286     MOV W6, W5
0018E2  420205     ADD W4, W5, W4
0018E4  B81000     MUL.UU W2, W0, W0
0018E6  420201     ADD W4, W1, W4
0018E8  780084     MOV W4, W1
0018EA  DD094A     SL W1, #10, W2
0018EC  DE0046     LSR W0, #6, W0
0018EE  710000     IOR W2, W0, W0
0018F0  DE88C6     ASR W1, #6, W1
0018F2  780080     MOV W0, W1
0018F4  209500     MOV #0x950, W0
0018F6  980031     MOV W1, [W0+6]
267:                   motor_right.current = SIG_VELRtmp * ADCValueTmp[1] >> 6; //Divisione o shifth
0018F8  90002E     MOV [W14+4], W0
0018FA  B90161     MUL.SU W0, #1, W2
0018FC  90005E     MOV [W14+10], W0
0018FE  9000EE     MOV [W14+12], W1
001900  B99A00     MUL.SS W3, W0, W4
001902  780204     MOV W4, W4
001904  B98B02     MUL.SS W1, W2, W6
001906  780286     MOV W6, W5
001908  420205     ADD W4, W5, W4
00190A  B81000     MUL.UU W2, W0, W0
00190C  420201     ADD W4, W1, W4
00190E  780084     MOV W4, W1
001910  DD094A     SL W1, #10, W2
001912  DE0046     LSR W0, #6, W0
001914  710000     IOR W2, W0, W0
001916  DE88C6     ASR W1, #6, W1
001918  780080     MOV W0, W1
00191A  209580     MOV #0x958, W0
00191C  980031     MOV W1, [W0+6]
268:               }
00191E  FA8000     ULNK
001920  060000     RETURN
---  C:/Users/Raffaello/Dropbox/MicrochipProject/dsPIC33MotionControl.X/main.c  -------------------------
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                
17:                #include <stdint.h>        /* Includes uint16_t definition                    */
18:                #include <stdbool.h>       /* Includes true/false definition                  */
19:                
20:                #include "system.h"        /* System funct/params, like osc/peripheral config */
21:                #include "user.h"          /* User funct/params, such as InitApp              */
22:                #include "motors_PID.h"
23:                #include "high_level_control.h"
24:                
25:                /******************************************************************************/
26:                /* Global Variable Declaration                                                */
27:                /******************************************************************************/
28:                
29:                /* i.e. uint16_t <variable_name>; */
30:                
31:                /******************************************************************************/
32:                /* Main Program                                                               */
33:                
34:                /******************************************************************************/
35:                
36:                int16_t main(void) {
0021DC  FA0000     LNK #0x0
37:                
38:                    /* Configure the oscillator for the device */
39:                    ConfigureOscillator();
0021DE  07FBE9     RCALL ConfigureOscillator
40:                
41:                    /* Initialize variables for robots */
42:                    init_parameter();
0021E0  07F82B     RCALL init_parameter
43:                    init_process();
0021E2  07FB9F     RCALL init_process
44:                    init_pid_control();
0021E4  07F8C8     RCALL init_pid_control
45:                
46:                    /* Initialize pid controllers */
47:                    update_pid_l();
0021E6  07F8E2     RCALL update_pid_l
48:                    update_pid_r();
0021E8  07F947     RCALL update_pid_r
49:                
50:                    /* Initialize dead reckoning */
51:                    init_coordinate();
0021EA  07FD7B     RCALL init_coordinate
52:                
53:                    /* Initialize IO ports and peripherals */
54:                    InitApp();
0021EC  07FF24     RCALL InitApp
55:                
56:                    while (1) {
57:                
58:                    }
0021EE  37FFFF     BRA 0x21EE
59:                }
---  C:/Users/Raffaello/Dropbox/MicrochipProject/dsPIC33MotionControl.X/interrupts.c  -------------------
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                #include <stdint.h>        /* Includes uint16_t definition   */
17:                #include <stdbool.h>       /* Includes true/false definition */
18:                
19:                #include "user.h"
20:                #include "serial.h"
21:                #include "parsing_packet.h"
22:                #include "motors_PID.h"
23:                #include "high_level_control.h"
24:                
25:                #define PID_FLAG IFS0bits.OC1IF
26:                #define PARSER_FLAG IFS0bits.OC2IF
27:                #define DEAD_RECKONING_FLAG IFS3bits.RTCIF
28:                
29:                /******************************************************************************/
30:                /* Global Variable Declaration                                                */
31:                /******************************************************************************/
32:                
33:                unsigned int counter = 0;
34:                unsigned int counter_odo = 0;
35:                volatile unsigned int overTmrL = 0;
36:                volatile unsigned int overTmrR = 0;
37:                volatile unsigned long timePeriodL = 0; //Periodo Ruota Sinistra
38:                volatile unsigned long timePeriodR = 0; //Periodo Ruota Destra
39:                volatile unsigned SIG_VELL = 0; //Verso rotazione ruota sinistra
40:                volatile unsigned SIG_VELR = 0; //Verso rotazione ruota destra
41:                volatile process_t time, priority, frequency;
42:                
43:                /******************************************************************************/
44:                /* Interrupt Vector Options                                                   */
45:                /******************************************************************************/
46:                /*                                                                            */
47:                /* Refer to the C30 (MPLAB C Compiler for PIC24F MCUs and dsPIC33F DSCs) User */
48:                /* Guide for an up to date list of the available interrupt options.           */
49:                /* Alternately these names can be pulled from the device linker scripts.      */
50:                /*                                                                            */
51:                /* dsPIC33F Primary Interrupt Vector Names:                                   */
52:                /*                                                                            */
53:                /* _INT0Interrupt      _C1Interrupt                                           */
54:                /* _IC1Interrupt       _DMA3Interrupt                                         */
55:                /* _OC1Interrupt       _IC3Interrupt                                          */
56:                /* _T1Interrupt        _IC4Interrupt                                          */
57:                /* _DMA0Interrupt      _IC5Interrupt                                          */
58:                /* _IC2Interrupt       _IC6Interrupt                                          */
59:                /* _OC2Interrupt       _OC5Interrupt                                          */
60:                /* _T2Interrupt        _OC6Interrupt                                          */
61:                /* _T3Interrupt        _OC7Interrupt                                          */
62:                /* _SPI1ErrInterrupt   _OC8Interrupt                                          */
63:                /* _SPI1Interrupt      _DMA4Interrupt                                         */
64:                /* _U1RXInterrupt      _T6Interrupt                                           */
65:                /* _U1TXInterrupt      _T7Interrupt                                           */
66:                /* _ADC1Interrupt      _SI2C2Interrupt                                        */
67:                /* _DMA1Interrupt      _MI2C2Interrupt                                        */
68:                /* _SI2C1Interrupt     _T8Interrupt                                           */
69:                /* _MI2C1Interrupt     _T9Interrupt                                           */
70:                /* _CNInterrupt        _INT3Interrupt                                         */
71:                /* _INT1Interrupt      _INT4Interrupt                                         */
72:                /* _ADC2Interrupt      _C2RxRdyInterrupt                                      */
73:                /* _DMA2Interrupt      _C2Interrupt                                           */
74:                /* _OC3Interrupt       _DCIErrInterrupt                                       */
75:                /* _OC4Interrupt       _DCIInterrupt                                          */
76:                /* _T4Interrupt        _DMA5Interrupt                                         */
77:                /* _T5Interrupt        _U1ErrInterrupt                                        */
78:                /* _INT2Interrupt      _U2ErrInterrupt                                        */
79:                /* _U2RXInterrupt      _DMA6Interrupt                                         */
80:                /* _U2TXInterrupt      _DMA7Interrupt                                         */
81:                /* _SPI2ErrInterrupt   _C1TxReqInterrupt                                      */
82:                /* _SPI2Interrupt      _C2TxReqInterrupt                                      */
83:                /* _C1RxRdyInterrupt                                                          */
84:                /*                                                                            */
85:                /* dsPIC33E Primary Interrupt Vector Names:                                   */
86:                /*                                                                            */
87:                /* _INT0Interrupt     _IC4Interrupt      _U4TXInterrupt                       */
88:                /* _IC1Interrupt      _IC5Interrupt      _SPI3ErrInterrupt                    */
89:                /* _OC1Interrupt      _IC6Interrupt      _SPI3Interrupt                       */
90:                /* _T1Interrupt       _OC5Interrupt      _OC9Interrupt                        */
91:                /* _DMA0Interrupt     _OC6Interrupt      _IC9Interrupt                        */
92:                /* _IC2Interrupt      _OC7Interrupt      _PWM1Interrupt                       */
93:                /* _OC2Interrupt      _OC8Interrupt      _PWM2Interrupt                       */
94:                /* _T2Interrupt       _PMPInterrupt      _PWM3Interrupt                       */
95:                /* _T3Interrupt       _DMA4Interrupt     _PWM4Interrupt                       */
96:                /* _SPI1ErrInterrupt  _T6Interrupt       _PWM5Interrupt                       */
97:                /* _SPI1Interrupt     _T7Interrupt       _PWM6Interrupt                       */
98:                /* _U1RXInterrupt     _SI2C2Interrupt    _PWM7Interrupt                       */
99:                /* _U1TXInterrupt     _MI2C2Interrupt    _DMA8Interrupt                       */
100:               /* _AD1Interrupt      _T8Interrupt       _DMA9Interrupt                       */
101:               /* _DMA1Interrupt     _T9Interrupt       _DMA10Interrupt                      */
102:               /* _NVMInterrupt      _INT3Interrupt     _DMA11Interrupt                      */
103:               /* _SI2C1Interrupt    _INT4Interrupt     _SPI4ErrInterrupt                    */
104:               /* _MI2C1Interrupt    _C2RxRdyInterrupt  _SPI4Interrupt                       */
105:               /* _CM1Interrupt      _C2Interrupt       _OC10Interrupt                       */
106:               /* _CNInterrupt       _QEI1Interrupt     _IC10Interrupt                       */
107:               /* _INT1Interrupt     _DCIEInterrupt     _OC11Interrupt                       */
108:               /* _AD2Interrupt      _DCIInterrupt      _IC11Interrupt                       */
109:               /* _IC7Interrupt      _DMA5Interrupt     _OC12Interrupt                       */
110:               /* _IC8Interrupt      _RTCCInterrupt     _IC12Interrupt                       */
111:               /* _DMA2Interrupt     _U1ErrInterrupt    _DMA12Interrupt                      */
112:               /* _OC3Interrupt      _U2ErrInterrupt    _DMA13Interrupt                      */
113:               /* _OC4Interrupt      _CRCInterrupt      _DMA14Interrupt                      */
114:               /* _T4Interrupt       _DMA6Interrupt     _OC13Interrupt                       */
115:               /* _T5Interrupt       _DMA7Interrupt     _IC13Interrupt                       */
116:               /* _INT2Interrupt     _C1TxReqInterrupt  _OC14Interrupt                       */
117:               /* _U2RXInterrupt     _C2TxReqInterrupt  _IC14Interrupt                       */
118:               /* _U2TXInterrupt     _QEI2Interrupt     _OC15Interrupt                       */
119:               /* _SPI2ErrInterrupt  _U3ErrInterrupt    _IC15Interrupt                       */
120:               /* _SPI2Interrupt     _U3RXInterrupt     _OC16Interrupt                       */
121:               /* _C1RxRdyInterrupt  _U3TXInterrupt     _IC16Interrupt                       */
122:               /* _C1Interrupt       _USB1Interrupt     _ICDInterrupt                        */
123:               /* _DMA3Interrupt     _U4ErrInterrupt    _PWMSpEventMatchInterrupt            */
124:               /* _IC3Interrupt      _U4RXInterrupt     _PWMSecSpEventMatchInterrupt         */
125:               /*                                                                            */
126:               /* For alternate interrupt vector naming, simply add 'Alt' between the prim.  */
127:               /* interrupt vector name '_' and the first character of the primary interrupt */
128:               /* vector name.  There is no Alternate Vector or 'AIVT' for the 33E family.   */
129:               /*                                                                            */
130:               /* For example, the vector name _ADC2Interrupt becomes _AltADC2Interrupt in   */
131:               /* the alternate vector table.                                                */
132:               /*                                                                            */
133:               /* Example Syntax:                                                            */
134:               /*                                                                            */
135:               /* void __attribute__((interrupt,auto_psv)) <Vector Name>(void)               */
136:               /* {                                                                          */
137:               /*     <Clear Interrupt Flag>                                                 */
138:               /* }                                                                          */
139:               /*                                                                            */
140:               /* For more comprehensive interrupt examples refer to the C30 (MPLAB C        */
141:               /* Compiler for PIC24 MCUs and dsPIC DSCs) User Guide in the                  */
142:               /* <C30 compiler instal directory>/doc directory for the latest compiler      */
143:               /* release.  For XC16, refer to the MPLAB XC16 C Compiler User's Guide in the */
144:               /* <XC16 compiler instal directory>/doc folder.                               */
145:               /*                                                                            */
146:               /******************************************************************************/
147:               /* Interrupt Routines                                                         */
148:               
149:               /******************************************************************************/
150:               
151:               void __attribute__((interrupt, auto_psv, shadow)) _IC1Interrupt(void) {
00029C  FEA000     PUSH.S
00029E  F80034     PUSH PSVPAG
0002A0  781F88     MOV W8, [W15++]
0002A2  200008     MOV #0x0, W8
0002A4  8801A8     MOV W8, PSVPAG
0002A6  78044F     MOV [--W15], W8
0002A8  FA0004     LNK #0x4
152:                   unsigned int t1, t2;
153:                   t2 = IC1BUF;
0002AA  800A00     MOV IC1BUF, W0
0002AC  780F00     MOV W0, [W14]
154:                   t1 = IC1BUF;
0002AE  800A00     MOV IC1BUF, W0
0002B0  980710     MOV W0, [W14+2]
155:                   IFS0bits.IC1IF = 0;
0002B2  A92084     BCLR IFS0, #1
156:                   timePeriodL = overTmrL * PR2 + t2 - t1;
0002B4  804D41     MOV 0x9A8, W1
0002B6  800860     MOV PR2, W0
0002B8  B98800     MUL.SS W1, W0, W0
0002BA  780000     MOV W0, W0
0002BC  40009E     ADD W0, [W14], W1
0002BE  90001E     MOV [W14+2], W0
0002C0  508000     SUB W1, W0, W0
0002C2  200001     MOV #0x0, W1
0002C4  884D60     MOV W0, 0x9AC
0002C6  884D71     MOV W1, 0x9AE
157:                   overTmrL = 0;
0002C8  EB0000     CLR W0
0002CA  884D40     MOV W0, 0x9A8
158:                   //	if(QEI1CONbits.UPDN) SIG_VELL++;		//Save sign Vel L
159:                   //	else SIG_VELL--;
160:                   //	if(t2>t1)
161:                   //		timePeriodL = t2 - t1;
162:                   //	else
163:                   //		timePeriodL = (PR2 - t1) + t2;
164:                   SIG_VELL = (QEI1CONbits.UPDN ? 1 : -1); //Save sign Vel L
0002CC  800F01     MOV QEI1CON, W1
0002CE  208000     MOV #0x800, W0
0002D0  608000     AND W1, W0, W0
0002D2  500FE0     SUB W0, #0x0, [W15]
0002D4  320002     BRA Z, 0x2DA
0002D6  200010     MOV #0x1, W0
0002D8  370001     BRA 0x2DC
0002DA  EB8000     SETM W0
0002DC  884DA0     MOV W0, 0x9B4
165:               }
0002DE  FA8000     ULNK
0002E0  F90034     POP PSVPAG
0002E2  FE8000     POP.S
0002E4  064000     RETFIE
166:               
167:               void __attribute__((interrupt, auto_psv, shadow)) _IC2Interrupt(void) {
0002E6  FEA000     PUSH.S
0002E8  F80034     PUSH PSVPAG
0002EA  781F88     MOV W8, [W15++]
0002EC  200008     MOV #0x0, W8
0002EE  8801A8     MOV W8, PSVPAG
0002F0  78044F     MOV [--W15], W8
0002F2  FA0004     LNK #0x4
168:                   unsigned int t1, t2;
169:                   t2 = IC2BUF;
0002F4  800A20     MOV IC2BUF, W0
0002F6  780F00     MOV W0, [W14]
170:                   t1 = IC2BUF;
0002F8  800A20     MOV IC2BUF, W0
0002FA  980710     MOV W0, [W14+2]
171:                   IFS0bits.IC2IF = 0;
0002FC  A9A084     BCLR IFS0, #5
172:                   timePeriodR = overTmrR * PR2 + t2 - t1;
0002FE  804D51     MOV 0x9AA, W1
000300  800860     MOV PR2, W0
000302  B98800     MUL.SS W1, W0, W0
000304  780000     MOV W0, W0
000306  40009E     ADD W0, [W14], W1
000308  90001E     MOV [W14+2], W0
00030A  508000     SUB W1, W0, W0
00030C  200001     MOV #0x0, W1
00030E  884D80     MOV W0, 0x9B0
000310  884D91     MOV W1, 0x9B2
173:                   overTmrR = 0;
000312  EB0000     CLR W0
000314  884D50     MOV W0, 0x9AA
174:                   //	if(QEI2CONbits.UPDN) SIG_VELR++;		//Save sign Vel R
175:                   //	else SIG_VELR--;
176:                   //	if(t2>t1)
177:                   //		timePeriodR = t2 - t1;
178:                   //	else
179:                   //		timePeriodR = (PR2 - t1) + t2;
180:                   //Encoder speculare rispetto all'altro. Segni invertiti
181:                   SIG_VELR = (QEI2CONbits.UPDN ? 1 : -1); //Save sign Vel R
000316  800F81     MOV QEI2CON, W1
000318  208000     MOV #0x800, W0
00031A  608000     AND W1, W0, W0
00031C  500FE0     SUB W0, #0x0, [W15]
00031E  320002     BRA Z, 0x324
000320  200010     MOV #0x1, W0
000322  370001     BRA 0x326
000324  EB8000     SETM W0
000326  884DB0     MOV W0, 0x9B6
182:               }
000328  FA8000     ULNK
00032A  F90034     POP PSVPAG
00032C  FE8000     POP.S
00032E  064000     RETFIE
183:               
184:               void __attribute__((interrupt, auto_psv)) _T1Interrupt(void) {
000330  F80036     PUSH RCOUNT
000332  BE9F80     MOV.D W0, [W15++]
000334  781F82     MOV W2, [W15++]
000336  F80034     PUSH PSVPAG
000338  200000     MOV #0x0, W0
00033A  8801A0     MOV W0, PSVPAG
00033C  FA0000     LNK #0x0
185:                   IFS0bits.T1IF = 0; // Clear Timer 1 Interrupt Flag
00033E  A96084     BCLR IFS0, #3
186:               
187:                   PID_FLAG = 1; //Start OC1Interrupt for PID control
000340  A84084     BSET IFS0, #2
188:                   if (!(counter_odo % 10)) {
000342  804D31     MOV 0x9A6, W1
000344  2000A0     MOV #0xA, W0
000346  780100     MOV W0, W2
000348  090011     REPEAT #0x11
00034A  D88082     DIV.UW W1, W2
00034C  FD0080     EXCH W0, W1
00034E  500FE0     SUB W0, #0x0, [W15]
000350  3A0003     BRA NZ, 0x358
189:                       DEAD_RECKONING_FLAG = 1;
000352  A8C08B     BSET 0x8B, #6
190:                       counter_odo = 0;
000354  EB0000     CLR W0
000356  884D30     MOV W0, 0x9A6
191:                   }
192:                   if (!(counter % 500)) {
000358  804D21     MOV 0x9A4, W1
00035A  201F40     MOV #0x1F4, W0
00035C  780100     MOV W0, W2
00035E  090011     REPEAT #0x11
000360  D88082     DIV.UW W1, W2
000362  FD0080     EXCH W0, W1
000364  500FE0     SUB W0, #0x0, [W15]
000366  3A000F     BRA NZ, 0x386
193:                       LED ^= 1;
000368  801620     MOV LATA, W0
00036A  DE0044     LSR W0, #4, W0
00036C  604061     AND.B W0, #0x1, W0
00036E  A20400     BTG.B W0, #0
000370  604061     AND.B W0, #0x1, W0
000372  FB8000     ZE W0, W0
000374  600061     AND W0, #0x1, W0
000376  DD0044     SL W0, #4, W0
000378  801622     MOV LATA, W2
00037A  2FFEF1     MOV #0xFFEF, W1
00037C  610081     AND W2, W1, W1
00037E  708000     IOR W1, W0, W0
000380  881620     MOV W0, LATA
194:                       counter = 0;
000382  EB0000     CLR W0
000384  884D20     MOV W0, 0x9A4
195:                   }
196:                   counter++;
000386  804D20     MOV 0x9A4, W0
000388  E80000     INC W0, W0
00038A  884D20     MOV W0, 0x9A4
197:                   counter_odo++;
00038C  804D30     MOV 0x9A6, W0
00038E  E80000     INC W0, W0
000390  884D30     MOV W0, 0x9A6
198:               }
000392  FA8000     ULNK
000394  F90034     POP PSVPAG
000396  78014F     MOV [--W15], W2
000398  BE004F     MOV.D [--W15], W0
00039A  F90036     POP RCOUNT
00039C  064000     RETFIE
199:               
200:               void __attribute__((interrupt, auto_psv, shadow)) _T2Interrupt(void) {
00039E  FEA000     PUSH.S
0003A0  F80034     PUSH PSVPAG
0003A2  781F88     MOV W8, [W15++]
0003A4  200008     MOV #0x0, W8
0003A6  8801A8     MOV W8, PSVPAG
0003A8  78044F     MOV [--W15], W8
0003AA  FA0000     LNK #0x0
201:                   IFS0bits.T2IF = 0; // interrupt flag reset
0003AC  A9E084     BCLR IFS0, #7
202:                   if (timePeriodL) overTmrL++; // overflow timer for Left engines
0003AE  804D60     MOV 0x9AC, W0
0003B0  804D71     MOV 0x9AE, W1
0003B2  500FE0     SUB W0, #0x0, [W15]
0003B4  588FE0     SUBB W1, #0x0, [W15]
0003B6  320003     BRA Z, 0x3BE
0003B8  804D40     MOV 0x9A8, W0
0003BA  E80000     INC W0, W0
0003BC  884D40     MOV W0, 0x9A8
203:                   if (timePeriodR) overTmrR++; // overflow timer for Right engines
0003BE  804D80     MOV 0x9B0, W0
0003C0  804D91     MOV 0x9B2, W1
0003C2  500FE0     SUB W0, #0x0, [W15]
0003C4  588FE0     SUBB W1, #0x0, [W15]
0003C6  320003     BRA Z, 0x3CE
0003C8  804D50     MOV 0x9AA, W0
0003CA  E80000     INC W0, W0
0003CC  884D50     MOV W0, 0x9AA
204:               }
0003CE  FA8000     ULNK
0003D0  F90034     POP PSVPAG
0003D2  FE8000     POP.S
0003D4  064000     RETFIE
205:               
206:               void __attribute__((interrupt, auto_psv)) _OC1Interrupt(void) {
0003D6  F80036     PUSH RCOUNT
0003D8  BE9F80     MOV.D W0, [W15++]
0003DA  BE9F82     MOV.D W2, [W15++]
0003DC  BE9F84     MOV.D W4, [W15++]
0003DE  BE9F86     MOV.D W6, [W15++]
0003E0  F80034     PUSH PSVPAG
0003E2  200000     MOV #0x0, W0
0003E4  8801A0     MOV W0, PSVPAG
0003E6  FA0000     LNK #0x0
207:                   PID_FLAG = 0; // interrupt flag reset
0003E8  A94084     BCLR IFS0, #2
208:                   time.velocity = Velocity();
0003EA  0708C4     RCALL Velocity
0003EC  8A3ED0     MOV W0, 0x47DA
209:                   time.pid_l = MotorPIDL();
0003EE  0709AF     RCALL MotorPIDL
0003F0  8A3EB0     MOV W0, 0x47D6
210:                   time.pid_r = MotorPIDR();
0003F2  0709F8     RCALL MotorPIDR
0003F4  8A3EC0     MOV W0, 0x47D8
211:               }
0003F6  FA8000     ULNK
0003F8  F90034     POP PSVPAG
0003FA  BE034F     MOV.D [--W15], W6
0003FC  BE024F     MOV.D [--W15], W4
0003FE  BE014F     MOV.D [--W15], W2
000400  BE004F     MOV.D [--W15], W0
000402  F90036     POP RCOUNT
000404  064000     RETFIE
212:               
213:               void __attribute__((interrupt, auto_psv)) _OC2Interrupt(void) {
000406  F80036     PUSH RCOUNT
000408  BE9F80     MOV.D W0, [W15++]
00040A  BE9F82     MOV.D W2, [W15++]
00040C  BE9F84     MOV.D W4, [W15++]
00040E  BE9F86     MOV.D W6, [W15++]
000410  F80034     PUSH PSVPAG
000412  200000     MOV #0x0, W0
000414  8801A0     MOV W0, PSVPAG
000416  FA0000     LNK #0x0
214:                   PARSER_FLAG = 0; //interrupt flag reset
000418  A9C084     BCLR IFS0, #6
215:                   time.parse_packet = parse_packet();
00041A  07038D     RCALL parse_packet
00041C  8A3EF0     MOV W0, 0x47DE
216:               }
00041E  FA8000     ULNK
000420  F90034     POP PSVPAG
000422  BE034F     MOV.D [--W15], W6
000424  BE024F     MOV.D [--W15], W4
000426  BE014F     MOV.D [--W15], W2
000428  BE004F     MOV.D [--W15], W0
00042A  F90036     POP RCOUNT
00042C  064000     RETFIE
217:               
218:               void __attribute__((interrupt, auto_psv)) _RTCCInterrupt(void) {
00042E  F80036     PUSH RCOUNT
000430  BE9F80     MOV.D W0, [W15++]
000432  BE9F82     MOV.D W2, [W15++]
000434  BE9F84     MOV.D W4, [W15++]
000436  BE9F86     MOV.D W6, [W15++]
000438  F80034     PUSH PSVPAG
00043A  200000     MOV #0x0, W0
00043C  8801A0     MOV W0, PSVPAG
00043E  FA0000     LNK #0x0
219:                   DEAD_RECKONING_FLAG = 0; //interrupt flag reset
000440  A9C08B     BCLR 0x8B, #6
220:                   time.dead_reckoning = deadReckoning();
000442  070C5E     RCALL deadReckoning
000444  8A3EE0     MOV W0, 0x47DC
221:               }
000446  FA8000     ULNK
000448  F90034     POP PSVPAG
00044A  BE034F     MOV.D [--W15], W6
00044C  BE024F     MOV.D [--W15], W4
00044E  BE014F     MOV.D [--W15], W2
000450  BE004F     MOV.D [--W15], W0
000452  F90036     POP RCOUNT
000454  064000     RETFIE
222:               
223:               unsigned int ReadUART1(void) {
000456  FA0000     LNK #0x0
224:                   if (U1MODEbits.PDSEL == 3)
000458  801100     MOV U1MODE, W0
00045A  600066     AND W0, #0x6, W0
00045C  500FE6     SUB W0, #0x6, [W15]
00045E  3A0002     BRA NZ, 0x464
225:                       return (U1RXREG);
000460  801130     MOV U1RXREG, W0
000462  370003     BRA 0x46A
226:                   else
227:                       return (U1RXREG & 0xFF);
000464  801131     MOV U1RXREG, W1
000466  200FF0     MOV #0xFF, W0
000468  608000     AND W1, W0, W0
228:               }
00046A  FA8000     ULNK
00046C  060000     RETURN
229:               
230:               void __attribute__((interrupt, auto_psv)) _U1RXInterrupt(void) {
00046E  F80036     PUSH RCOUNT
000470  BE9F80     MOV.D W0, [W15++]
000472  BE9F82     MOV.D W2, [W15++]
000474  BE9F84     MOV.D W4, [W15++]
000476  BE9F86     MOV.D W6, [W15++]
000478  F80034     PUSH PSVPAG
00047A  200000     MOV #0x0, W0
00047C  8801A0     MOV W0, PSVPAG
00047E  FA0000     LNK #0x0
231:                   IFS0bits.U1RXIF = 0; // clear RX interrupt flag
000480  A96085     BCLR 0x85, #3
232:               
233:                   /* get the data */
234:                   if (U1STAbits.URXDA == 1) {
000482  801110     MOV U1STA, W0
000484  600061     AND W0, #0x1, W0
000486  500FE0     SUB W0, #0x0, [W15]
000488  320007     BRA Z, 0x498
235:                       if (decode_pkgs(ReadUART1())) {
00048A  07FFE5     RCALL ReadUART1
00048C  784000     MOV.B W0, W0
00048E  070D32     RCALL decode_pkgs
000490  500FE0     SUB W0, #0x0, [W15]
000492  32000F     BRA Z, 0x4B2
236:                           PARSER_FLAG = 1; //if correct packet parse command start interrupt flag
000494  A8C084     BSET IFS0, #6
000496  37000D     BRA 0x4B2
237:                       }
238:                   } else {
239:                       /* check for receive errors */
240:                       if (U1STAbits.FERR == 1) {
000498  801110     MOV U1STA, W0
00049A  600064     AND W0, #0x4, W0
00049C  500FE0     SUB W0, #0x0, [W15]
00049E  320002     BRA Z, 0x4A4
241:                           pkg_error(ERROR_FRAMMING);
0004A0  EB8000     SETM W0
0004A2  070D7D     RCALL pkg_error
242:                       }
243:                       /* must clear the overrun error to keep uart receiving */
244:                       if (U1STAbits.OERR == 1) {
0004A4  801110     MOV U1STA, W0
0004A6  600062     AND W0, #0x2, W0
0004A8  500FE0     SUB W0, #0x0, [W15]
0004AA  320003     BRA Z, 0x4B2
245:                           U1STAbits.OERR = 0;
0004AC  A92222     BCLR U1STA, #1
246:                           pkg_error(ERROR_OVERRUN);
0004AE  2FFFE0     MOV #0xFFFE, W0
0004B0  070D76     RCALL pkg_error
247:                       }
248:                   }
249:               }
0004B2  FA8000     ULNK
0004B4  F90034     POP PSVPAG
0004B6  BE034F     MOV.D [--W15], W6
0004B8  BE024F     MOV.D [--W15], W4
0004BA  BE014F     MOV.D [--W15], W2
0004BC  BE004F     MOV.D [--W15], W0
0004BE  F90036     POP RCOUNT
0004C0  064000     RETFIE
250:               
251:               void __attribute__((interrupt, auto_psv)) _DMA0Interrupt(void) {
0004C2  F80036     PUSH RCOUNT
0004C4  BE9F80     MOV.D W0, [W15++]
0004C6  BE9F82     MOV.D W2, [W15++]
0004C8  BE9F84     MOV.D W4, [W15++]
0004CA  BE9F86     MOV.D W6, [W15++]
0004CC  F80034     PUSH PSVPAG
0004CE  200000     MOV #0x0, W0
0004D0  8801A0     MOV W0, PSVPAG
0004D2  FA0000     LNK #0x0
252:                   IFS0bits.DMA0IF = 0; // Clear the DMA0 Interrupt Flag
0004D4  A98084     BCLR IFS0, #4
253:                   adc_motors_current(); // Esecution mean value for current motors
0004D6  0709CF     RCALL adc_motors_current
254:               }
0004D8  FA8000     ULNK
0004DA  F90034     POP PSVPAG
0004DC  BE034F     MOV.D [--W15], W6
0004DE  BE024F     MOV.D [--W15], W4
0004E0  BE014F     MOV.D [--W15], W2
0004E2  BE004F     MOV.D [--W15], W0
0004E4  F90036     POP RCOUNT
0004E6  064000     RETFIE
255:               
256:               void __attribute__((interrupt, auto_psv)) _DMA1Interrupt(void) {
0004E8  F80034     PUSH PSVPAG
0004EA  781F88     MOV W8, [W15++]
0004EC  200008     MOV #0x0, W8
0004EE  8801A8     MOV W8, PSVPAG
0004F0  78044F     MOV [--W15], W8
0004F2  FA0000     LNK #0x0
257:                   IFS0bits.DMA1IF = 0; // Clear the DMA1 Interrupt Flag
0004F4  A9C085     BCLR 0x85, #6
258:               }
0004F6  FA8000     ULNK
0004F8  F90034     POP PSVPAG
0004FA  064000     RETFIE
---  C:/Users/Raffaello/Dropbox/MicrochipProject/dsPIC33MotionControl.X/high_level_control.c  -----------
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                #include <stdint.h>          /* For uint16_t definition                       */
17:                #include <stdbool.h>         /* For true/false definition                     */
18:                #include <dsp.h>
19:                #include <string.h>
20:                #include <float.h>
21:                
22:                #include "high_level_control.h"
23:                #include "motors_PID.h"
24:                
25:                coordinate_t coordinate;
26:                
27:                float sinTh_old = 0, cosTh_old = 1;
28:                
29:                // From motors PID
30:                extern volatile parameter_t parameter;
31:                extern volatile int PulsEncL, PulsEncR;
32:                extern k_odo_t k_odo;
33:                extern float wheel_m;
34:                
35:                /******************************************************************************/
36:                /* Dead Reckoning functions                                                   */
37:                
38:                /******************************************************************************/
39:                
40:                void init_coordinate(void) {
001CE2  FA0000     LNK #0x0
41:                    coordinate.x = 0;
001CE4  B80060     MUL.UU W0, #0, W0
001CE6  884DC0     MOV W0, coordinate
001CE8  884DD1     MOV W1, 0x9BA
42:                    coordinate.y = 0;
001CEA  B80060     MUL.UU W0, #0, W0
001CEC  884DE0     MOV W0, 0x9BC
001CEE  884DF1     MOV W1, 0x9BE
43:                    coordinate.theta = 0;
001CF0  B80060     MUL.UU W0, #0, W0
001CF2  884E00     MOV W0, 0x9C0
001CF4  884E11     MOV W1, 0x9C2
44:                    coordinate.space = 0;
001CF6  B80060     MUL.UU W0, #0, W0
001CF8  884E20     MOV W0, 0x9C4
001CFA  884E31     MOV W1, 0x9C6
45:                }
001CFC  FA8000     ULNK
001CFE  060000     RETURN
46:                
47:                int deadReckoning(void) {
001D00  FA002E     LNK #0x2E
001D02  BE9F88     MOV.D W8, [W15++]
48:                    unsigned int t = TMR1; // Timing function
001D04  800800     MOV TMR1, W0
001D06  780F00     MOV W0, [W14]
49:                    volatile coordinate_t delta;
50:                    float WheelSpL = k_odo.k_left * PulsEncL; // Spostamento Ruota sinistra
001D08  2096C0     MOV #0x96C, W0
001D0A  BE0410     MOV.D [W0], W8
001D0C  804E60     MOV 0x9CC, W0
001D0E  DE80CF     ASR W0, #15, W1
001D10  07F558     RCALL ___floatsisf
001D12  BE0100     MOV.D W0, W2
001D14  BE0008     MOV.D W8, W0
001D16  07F5FE     RCALL ___mulsf3
001D18  980710     MOV W0, [W14+2]
001D1A  980721     MOV W1, [W14+4]
51:                    float WheelSpR = k_odo.k_right * PulsEncR; // Spostamento Ruota destra
001D1C  2096C0     MOV #0x96C, W0
001D1E  900420     MOV [W0+4], W8
001D20  9004B0     MOV [W0+6], W9
001D22  804E70     MOV 0x9CE, W0
001D24  DE80CF     ASR W0, #15, W1
001D26  07F54D     RCALL ___floatsisf
001D28  BE0100     MOV.D W0, W2
001D2A  BE0008     MOV.D W8, W0
001D2C  07F5F3     RCALL ___mulsf3
001D2E  980730     MOV W0, [W14+6]
001D30  980741     MOV W1, [W14+8]
52:                    float SumSp = WheelSpR + WheelSpL; // Calcolo della somma degli spostamenti delle ruote
001D32  90011E     MOV [W14+2], W2
001D34  9001AE     MOV [W14+4], W3
001D36  90003E     MOV [W14+6], W0
001D38  9000CE     MOV [W14+8], W1
001D3A  07F46E     RCALL ___addsf3
001D3C  980750     MOV W0, [W14+10]
001D3E  980761     MOV W1, [W14+12]
53:                    float DifSp = WheelSpR - WheelSpL; // Calcolo della differenza degli spostamenti delle ruote
001D40  90011E     MOV [W14+2], W2
001D42  9001AE     MOV [W14+4], W3
001D44  90003E     MOV [W14+6], W0
001D46  9000CE     MOV [W14+8], W1
001D48  07F466     RCALL ___subsf3
001D4A  980770     MOV W0, [W14+14]
001D4C  980F01     MOV W1, [W14+16]
54:                    PulsEncL = 0; // Flush variabile
001D4E  EB0000     CLR W0
001D50  884E60     MOV W0, 0x9CC
55:                    PulsEncR = 0; // Flush variabile
001D52  EB0000     CLR W0
001D54  884E70     MOV W0, 0x9CE
56:                
57:                    if (fabs(DifSp) <= parameter.sp_min) {
001D56  90007E     MOV [W14+14], W0
001D58  90088E     MOV [W14+16], W1
001D5A  BE0200     MOV.D W0, W4
001D5C  A1F005     BCLR W5, #15
001D5E  8048B0     MOV 0x916, W0
001D60  8048C1     MOV 0x918, W1
001D62  B3C018     MOV #0x1, W8
001D64  BE0100     MOV.D W0, W2
001D66  BE0004     MOV.D W4, W0
001D68  07F507     RCALL ___lesf2
001D6A  500FE0     SUB W0, #0x0, [W15]
001D6C  340001     BRA LE, 0x1D70
001D6E  EB4400     CLR.B W8
001D70  544FE0     SUB.B W8, #0x0, [W15]
001D72  32001A     BRA Z, 0x1DA8
58:                        delta.theta = 0;
001D74  B80060     MUL.UU W0, #0, W0
001D76  981730     MOV W0, [W14+38]
001D78  981741     MOV W1, [W14+40]
59:                        delta.space = WheelSpR;
001D7A  90003E     MOV [W14+6], W0
001D7C  9000CE     MOV [W14+8], W1
001D7E  981750     MOV W0, [W14+42]
001D80  981761     MOV W1, [W14+44]
60:                        delta.x = delta.space * cosTh_old;
001D82  90125E     MOV [W14+42], W4
001D84  9012EE     MOV [W14+44], W5
001D86  823FE0     MOV 0x47FC, W0
001D88  823FF1     MOV 0x47FE, W1
001D8A  BE0100     MOV.D W0, W2
001D8C  BE0004     MOV.D W4, W0
001D8E  07F5C2     RCALL ___mulsf3
001D90  980F70     MOV W0, [W14+30]
001D92  981701     MOV W1, [W14+32]
61:                        delta.y = delta.space * sinTh_old;
001D94  90125E     MOV [W14+42], W4
001D96  9012EE     MOV [W14+44], W5
001D98  823FC0     MOV 0x47F8, W0
001D9A  823FD1     MOV 0x47FA, W1
001D9C  BE0100     MOV.D W0, W2
001D9E  BE0004     MOV.D W4, W0
001DA0  07F5B9     RCALL ___mulsf3
001DA2  981710     MOV W0, [W14+34]
001DA4  981721     MOV W1, [W14+36]
001DA6  370086     BRA 0x1EB4
62:                    } else if (fabs(SumSp) <= parameter.sp_min) {
001DA8  90005E     MOV [W14+10], W0
001DAA  9000EE     MOV [W14+12], W1
001DAC  BE0200     MOV.D W0, W4
001DAE  A1F005     BCLR W5, #15
001DB0  8048B0     MOV 0x916, W0
001DB2  8048C1     MOV 0x918, W1
001DB4  B3C018     MOV #0x1, W8
001DB6  BE0100     MOV.D W0, W2
001DB8  BE0004     MOV.D W4, W0
001DBA  07F4DE     RCALL ___lesf2
001DBC  500FE0     SUB W0, #0x0, [W15]
001DBE  340001     BRA LE, 0x1DC2
001DC0  EB4400     CLR.B W8
001DC2  544FE0     SUB.B W8, #0x0, [W15]
001DC4  320028     BRA Z, 0x1E16
63:                        delta.theta = DifSp / parameter.wheelbase;
001DC6  804810     MOV 0x902, W0
001DC8  804821     MOV 0x904, W1
001DCA  BE0100     MOV.D W0, W2
001DCC  90007E     MOV [W14+14], W0
001DCE  90088E     MOV [W14+16], W1
001DD0  07F482     RCALL ___divsf3
001DD2  981730     MOV W0, [W14+38]
001DD4  981741     MOV W1, [W14+40]
64:                        coordinate.theta = fmodf(coordinate.theta + delta.theta, 2 * PI); // Angolo normalizzato tra [0,2*PI]
001DD6  804E04     MOV 0x9C0, W4
001DD8  804E15     MOV 0x9C2, W5
001DDA  90103E     MOV [W14+38], W0
001DDC  9010CE     MOV [W14+40], W1
001DDE  BE0100     MOV.D W0, W2
001DE0  BE0004     MOV.D W4, W0
001DE2  07F41A     RCALL ___addsf3
001DE4  20FDB2     MOV #0xFDB, W2
001DE6  240C93     MOV #0x40C9, W3
001DE8  07F4F1     RCALL _fmodf
001DEA  884E00     MOV W0, 0x9C0
001DEC  884E11     MOV W1, 0x9C2
65:                        sinTh_old = sinf(coordinate.theta);
001DEE  804E00     MOV 0x9C0, W0
001DF0  804E11     MOV 0x9C2, W1
001DF2  07F62D     RCALL _sinf
001DF4  8A3FC0     MOV W0, 0x47F8
001DF6  8A3FD1     MOV W1, 0x47FA
66:                        cosTh_old = cosf(coordinate.theta);
001DF8  804E00     MOV 0x9C0, W0
001DFA  804E11     MOV 0x9C2, W1
001DFC  07F46A     RCALL _cosf
001DFE  8A3FE0     MOV W0, 0x47FC
001E00  8A3FF1     MOV W1, 0x47FE
67:                        delta.x = 0;
001E02  B80060     MUL.UU W0, #0, W0
001E04  980F70     MOV W0, [W14+30]
001E06  981701     MOV W1, [W14+32]
68:                        delta.y = 0;
001E08  B80060     MUL.UU W0, #0, W0
001E0A  981710     MOV W0, [W14+34]
001E0C  981721     MOV W1, [W14+36]
69:                        delta.space = 0;
001E0E  B80060     MUL.UU W0, #0, W0
001E10  981750     MOV W0, [W14+42]
001E12  981761     MOV W1, [W14+44]
001E14  37004F     BRA 0x1EB4
70:                    } else {
71:                        delta.theta = DifSp / parameter.wheelbase;
001E16  804810     MOV 0x902, W0
001E18  804821     MOV 0x904, W1
001E1A  BE0100     MOV.D W0, W2
001E1C  90007E     MOV [W14+14], W0
001E1E  90088E     MOV [W14+16], W1
001E20  07F45A     RCALL ___divsf3
001E22  981730     MOV W0, [W14+38]
001E24  981741     MOV W1, [W14+40]
72:                        coordinate.theta = fmodf(coordinate.theta + delta.theta, 2 * PI); // Angolo normalizzato tra [0,2*PI]
001E26  804E04     MOV 0x9C0, W4
001E28  804E15     MOV 0x9C2, W5
001E2A  90103E     MOV [W14+38], W0
001E2C  9010CE     MOV [W14+40], W1
001E2E  BE0100     MOV.D W0, W2
001E30  BE0004     MOV.D W4, W0
001E32  07F3F2     RCALL ___addsf3
001E34  20FDB2     MOV #0xFDB, W2
001E36  240C93     MOV #0x40C9, W3
001E38  07F4C9     RCALL _fmodf
001E3A  884E00     MOV W0, 0x9C0
001E3C  884E11     MOV W1, 0x9C2
73:                        float cosTh_new = cosf(coordinate.theta);
001E3E  804E00     MOV 0x9C0, W0
001E40  804E11     MOV 0x9C2, W1
001E42  07F447     RCALL _cosf
001E44  980F10     MOV W0, [W14+18]
001E46  980F21     MOV W1, [W14+20]
74:                        float sinTh_new = sinf(coordinate.theta);
001E48  804E00     MOV 0x9C0, W0
001E4A  804E11     MOV 0x9C2, W1
001E4C  07F600     RCALL _sinf
001E4E  980F30     MOV W0, [W14+22]
001E50  980F41     MOV W1, [W14+24]
75:                        delta.space = SumSp / 2;
001E52  200002     MOV #0x0, W2
001E54  240003     MOV #0x4000, W3
001E56  90005E     MOV [W14+10], W0
001E58  9000EE     MOV [W14+12], W1
001E5A  07F43D     RCALL ___divsf3
001E5C  981750     MOV W0, [W14+42]
001E5E  981761     MOV W1, [W14+44]
76:                        float radius = wheel_m * (SumSp / DifSp);
001E60  90017E     MOV [W14+14], W2
001E62  90098E     MOV [W14+16], W3
001E64  90005E     MOV [W14+10], W0
001E66  9000EE     MOV [W14+12], W1
001E68  07F436     RCALL ___divsf3
001E6A  BE0200     MOV.D W0, W4
001E6C  804BA0     MOV wheel_m, W0
001E6E  804BB1     MOV 0x976, W1
001E70  BE0100     MOV.D W0, W2
001E72  BE0004     MOV.D W4, W0
001E74  07F54F     RCALL ___mulsf3
001E76  980F50     MOV W0, [W14+26]
001E78  980F61     MOV W1, [W14+28]
77:                
78:                        delta.x = radius * (sinTh_new - sinTh_old);
001E7A  823FC0     MOV 0x47F8, W0
001E7C  823FD1     MOV 0x47FA, W1
001E7E  BE0100     MOV.D W0, W2
001E80  90083E     MOV [W14+22], W0
001E82  9008CE     MOV [W14+24], W1
001E84  07F3C8     RCALL ___subsf3
001E86  90095E     MOV [W14+26], W2
001E88  9009EE     MOV [W14+28], W3
001E8A  07F544     RCALL ___mulsf3
001E8C  980F70     MOV W0, [W14+30]
001E8E  981701     MOV W1, [W14+32]
79:                        delta.y = radius * (cosTh_old - cosTh_new);
001E90  823FE0     MOV 0x47FC, W0
001E92  823FF1     MOV 0x47FE, W1
001E94  90091E     MOV [W14+18], W2
001E96  9009AE     MOV [W14+20], W3
001E98  07F3BE     RCALL ___subsf3
001E9A  90095E     MOV [W14+26], W2
001E9C  9009EE     MOV [W14+28], W3
001E9E  07F53A     RCALL ___mulsf3
001EA0  981710     MOV W0, [W14+34]
001EA2  981721     MOV W1, [W14+36]
80:                        sinTh_old = sinTh_new;
001EA4  90083E     MOV [W14+22], W0
001EA6  9008CE     MOV [W14+24], W1
001EA8  8A3FC0     MOV W0, 0x47F8
001EAA  8A3FD1     MOV W1, 0x47FA
81:                        cosTh_old = cosTh_new;
001EAC  90081E     MOV [W14+18], W0
001EAE  9008AE     MOV [W14+20], W1
001EB0  8A3FE0     MOV W0, 0x47FC
001EB2  8A3FF1     MOV W1, 0x47FE
82:                    }
83:                    coordinate.space += delta.space;
001EB4  804E24     MOV 0x9C4, W4
001EB6  804E35     MOV 0x9C6, W5
001EB8  90105E     MOV [W14+42], W0
001EBA  9010EE     MOV [W14+44], W1
001EBC  BE0100     MOV.D W0, W2
001EBE  BE0004     MOV.D W4, W0
001EC0  07F3AB     RCALL ___addsf3
001EC2  884E20     MOV W0, 0x9C4
001EC4  884E31     MOV W1, 0x9C6
84:                    coordinate.x += delta.x;
001EC6  804DC4     MOV coordinate, W4
001EC8  804DD5     MOV 0x9BA, W5
001ECA  90087E     MOV [W14+30], W0
001ECC  90108E     MOV [W14+32], W1
001ECE  BE0100     MOV.D W0, W2
001ED0  BE0004     MOV.D W4, W0
001ED2  07F3A2     RCALL ___addsf3
001ED4  884DC0     MOV W0, coordinate
001ED6  884DD1     MOV W1, 0x9BA
85:                    coordinate.y += delta.y;
001ED8  804DE4     MOV 0x9BC, W4
001EDA  804DF5     MOV 0x9BE, W5
001EDC  90101E     MOV [W14+34], W0
001EDE  9010AE     MOV [W14+36], W1
001EE0  BE0100     MOV.D W0, W2
001EE2  BE0004     MOV.D W4, W0
001EE4  07F399     RCALL ___addsf3
001EE6  884DE0     MOV W0, 0x9BC
001EE8  884DF1     MOV W1, 0x9BE
86:                
87:                    return TMR1 - t; // Time of esecution
001EEA  800800     MOV TMR1, W0
001EEC  50001E     SUB W0, [W14], W0
88:                }
001EEE  BE044F     MOV.D [--W15], W8
001EF0  FA8000     ULNK
001EF2  060000     RETURN
